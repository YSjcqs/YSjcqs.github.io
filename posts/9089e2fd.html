<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Assembly学习记录 | 谨尘青丝</title><meta name="keywords" content="汇编"><meta name="author" content="幽姝"><meta name="copyright" content="幽姝"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="汇编学习记录">
<meta property="og:type" content="article">
<meta property="og:title" content="Assembly学习记录">
<meta property="og:url" content="https://ysjcqs.top/posts/9089e2fd.html">
<meta property="og:site_name" content="谨尘青丝">
<meta property="og:description" content="汇编学习记录">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.mtyqx.cn/api/random.php">
<meta property="article:published_time" content="2022-10-11T06:17:17.000Z">
<meta property="article:modified_time" content="2023-04-19T06:54:49.471Z">
<meta property="article:author" content="幽姝">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.mtyqx.cn/api/random.php"><link rel="shortcut icon" href="/img/favicon_img.png"><link rel="canonical" href="https://ysjcqs.top/posts/9089e2fd"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":1024},
  copy: {
    success: '🍊复制成功',
    error: '🍓复制错误',
    noSupport: '🍅浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":512,"languages":{"author":"作者: 幽姝","link":"链接: ","source":"来源: 谨尘青丝","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Assembly学习记录',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-19 14:54:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar_img.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 资源库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.mtyqx.cn/api/random.php')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">谨尘青丝</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 资源库</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Assembly学习记录</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-11T06:17:17.000Z" title="发表于 2022-10-11 14:17:17">2022-10-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-19T06:54:49.471Z" title="更新于 2023-04-19 14:54:49">2023-04-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/%E6%B1%87%E7%BC%96/">汇编</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Assembly学习记录"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="实模式-8086阶段"><a class="header-anchor" href="#实模式-8086阶段">¶</a>实模式+8086阶段</h1>
<h2 id="实模式内存布局"><a class="header-anchor" href="#实模式内存布局">¶</a>实模式内存布局</h2>
<table>
<thead>
<tr>
<th>起始</th>
<th>结束</th>
<th>大小</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>FFFF0</td>
<td>FFFFF</td>
<td>16B</td>
<td>BIOS入口地址，此地址也属于BIOS代码，同样属于顶部的640KB字节。只是为了强调其入口地址才单独i特出来。此处16字节的内容时跳转指令<code>jmp f000:e05b</code></td>
</tr>
<tr>
<td>F0000</td>
<td>FFFEF</td>
<td>64KB-16B</td>
<td>系统BIOS范围是F0000~FFFFF共640KB，为说明入口地址，将最上面的16字节从此处去掉，所以此处终止地址是0xFFFEF</td>
</tr>
<tr>
<td>C8000</td>
<td>EFFFF</td>
<td>160KB</td>
<td>映射硬件适配器的ROM或内存映射式I/O</td>
</tr>
<tr>
<td>C0000</td>
<td>C7FFF</td>
<td>32KB</td>
<td>显示适配器BIOS</td>
</tr>
<tr>
<td>B8000</td>
<td>BFFFF</td>
<td>32KB</td>
<td>用于文本模式显示适配器</td>
</tr>
<tr>
<td>B0000</td>
<td>B7FFF</td>
<td>32KB</td>
<td>用于黑白显示适配器</td>
</tr>
<tr>
<td>A0000</td>
<td>AFFFF</td>
<td>64KB</td>
<td>用于彩色显示适配器</td>
</tr>
<tr>
<td>9FC00</td>
<td>9FFFF</td>
<td>1KB</td>
<td>EBDA（Extended BIOS Area）扩展BIOS数据区</td>
</tr>
<tr>
<td>07E00</td>
<td>9FBFF</td>
<td>622080B约608KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>07C00</td>
<td>07DFF</td>
<td>512B</td>
<td>MBR被BIOS加载到此处，共512字节</td>
</tr>
<tr>
<td>00500</td>
<td>07BFF</td>
<td>30464B约30KB</td>
<td>可用区域</td>
</tr>
<tr>
<td>00400</td>
<td>004FF</td>
<td>256B</td>
<td>BIOS Data Area(BIOS数据区)</td>
</tr>
<tr>
<td>00000</td>
<td>003FF</td>
<td>1KB</td>
<td>Interrupt Vector Table（中断向量表）</td>
</tr>
</tbody>
</table>
<ul>
<li>逻辑地址和物理地址
<ul>
<li>00000~FFFFF中最低位字节位0时，就可以作为段基地址</li>
<li>物理地址=段基地址&gt;&gt;4 + 偏移地址（4个字节）</li>
<li>每个段的大小最大位64K，即65536个字节（偏移地址4个字节表示最大值）</li>
<li>实际物理地址最大值：10FFEF(段地址：FFFF0+偏移地址：FFFF)，当受限与20根地址线（超过了20个bit），最大只能访问到FFFFF</li>
</ul>
</li>
</ul>
<h2 id="寄存器"><a class="header-anchor" href="#寄存器">¶</a>寄存器</h2>
<h3 id="通用寄存器"><a class="header-anchor" href="#通用寄存器">¶</a>通用寄存器</h3>
<ul>
<li>AH&amp;AL＝AX(accumulator)：累加寄存器，常用于运算;在乘除等指令中指定用来存放操作数,另外,所有的I/O指令都使用这一寄存器与外界设备传送数据.</li>
<li>BH&amp;BL＝BX(base)：基址寄存器，常用于地址索引，用来提供数据访问，使用bx提供偏移地址时，段寄存器默认使用（指定使用需要加段超越前缀）ds提供段地址（bp默认访问栈段，bx默认访问数据段）</li>
<li>CH&amp;CL＝CX(count)：计数寄存器，常用于计数；常用于保存计算值,如在移位指令,循环(loop)和串处理指令中用作隐含的计数器.</li>
<li>DH&amp;DL＝DX(data)：数据寄存器，用来和外设之间进行数据传输</li>
<li>BP（Base Pointer）基址寄存器，用来提供访问栈段，使用bx提供偏移地址时，段寄存器默认使用ss提供段地址（bp默认访问栈段，bx默认访问数据段）</li>
<li>SP（Stack Pointer）：堆栈指针，与SS配合使用，可指向目前的堆栈位置；ss+sp=栈地址）【压栈操作：高地址(栈底)-&gt;低地址（栈顶）（8086每次压栈和出栈都是16字节）】</li>
<li>SI（Source Index）:源索引寄存器（或变址寄存器）(用法见movsb),si提供偏移地址时，段寄存器默认使用ds提供段地址</li>
<li>DI（Destination Index）：目标索引寄存器（或变址寄存器）(用法见movsb),di提供偏移地址时，段寄存器默认使用ds提供段地址</li>
</ul>
<h3 id="指针寄存器"><a class="header-anchor" href="#指针寄存器">¶</a>指针寄存器</h3>
<ul>
<li>指令指针IP(Instruction Pointer):指令指针IP是一个16位专用寄存器，它指向当前需要取出的指令字节，当BIU从内存中取出一个指令字节后，IP就自动加1，指向下一个指令字节。注意，IP指向的是指令地址的段内地址偏移量，又称偏移地址(Offset Address)或有效地址(EA，Effective Address)。</li>
</ul>
<h3 id="段寄存器"><a class="header-anchor" href="#段寄存器">¶</a>段寄存器</h3>
<blockquote>
<p>两个段寄存器之间不能直接传送数据，需要借助通用寄存器</p>
</blockquote>
<ul>
<li>CS： 代码段寄存器(Code Segment Register) ，其值为代码段的段值；</li>
<li>DS ： 数据段寄存器(Data Segment Register) ，其值为数据段的段值；段内访问地址默认位ds寄存器(不指定的情况下)（段内地址位偏移地址）</li>
<li>ES： 附加段寄存器(Extra Segment Register) ，其值为附加数据段的段值；</li>
<li>SS： 堆栈段寄存器(Stack Segment Register) ，其值为堆栈段的段值；</li>
</ul>
<h3 id="标志寄存器"><a class="header-anchor" href="#标志寄存器">¶</a>标志寄存器</h3>
<ul>
<li>FLAGS寄存器
<ul>
<li>bit0(CF):进位标志，当一个算术在结果最高位产生进位或者借位时，标志为1，否则为0
<ul>
<li>若al = 1000 0000则<code> add al, al</code> CF = 1</li>
</ul>
</li>
<li>bit2(PF):奇偶标志，当算术操作结果在低8位中有偶数个“1”时，此标志位1，反之则为0</li>
<li>bit4(AF):辅助进位标志，当一个算术操作在结果的位3（bit3）产生进位或者借位时，此为1，反则0</li>
<li>bit6(ZF):零标志，用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。</li>
<li>bit7(SF):符号位，用来反映运算结果的符号位，它与运算结果的最高位相同。在微机系统中，有符号数采用补码表示法，所以，SF也就反映运算结果的正负号。运算结果为正数时，SF的值为0，否则其值为1。</li>
<li>bit8(TF):跟踪标志。该标志可用于程序调试。TF标志没有专门的指令来设置或清楚。如果TF=1，则CPU处于单步执行指令的工作方式，此时每执行完一条指令，就显示CPU内各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。</li>
<li>bit9(IF):中断标志，中断允许标志IF位用来决定CPU是否响应CPU外部的可屏蔽中断发出的中断请求。但不管该标志为何值，CPU都必须响应CPU外部的不可屏蔽中断所发出的中断请求，以及CPU内部产生的中断请求。当IF=1时，CPU可以响应CPU外部的可屏蔽中断发出的中断请求；当IF=0时，CPU不响应CPU外部的可屏蔽中断发出的中断请求。</li>
<li>bit10(DF):方向标志，用来决定在串操作指令执行时有关指针寄存器发生调整的方向。</li>
<li>bit11(OF):溢出标志，<strong>对任何一个算术</strong>，假定算术为有符号运算，结果超出目标位置所能容纳最大正数或者最小负数时，此为1，反则0</li>
</ul>
</li>
</ul>
<h3 id="可以提供偏移地址的寄存器"><a class="header-anchor" href="#可以提供偏移地址的寄存器">¶</a>可以提供偏移地址的寄存器</h3>
<ul>
<li>可用BX，SI，DI，BP，其他都为非法
<ul>
<li><code>mov [ax], dl</code>非法指令</li>
<li><code>mov [dx], bl</code>非法指令</li>
</ul>
</li>
<li>基址变址组合
<ul>
<li><code>bx+si, bx+di, bp+si, bp+di</code></li>
<li>非法例子
<ul>
<li><code>bx+ax</code></li>
<li><code>ax+cs</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文本模式颜色表（80-X-25）"><a class="header-anchor" href="#文本模式颜色表（80-X-25）">¶</a>文本模式颜色表（80 X 25）</h2>
<blockquote>
<p>属性：KRGB IRGB（前4为背景色，后4为前景色）</p>
</blockquote>
<table>
<thead>
<tr>
<th>R</th>
<th>G</th>
<th>B</th>
<th>背景色（K=0不闪烁，K=1闪烁）</th>
<th>前景色I=0</th>
<th>前景色I=1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>黑</td>
<td>黑</td>
<td>灰</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>蓝</td>
<td>蓝</td>
<td>浅蓝</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>绿</td>
<td>绿</td>
<td>浅绿</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>青</td>
<td>青</td>
<td>浅青</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>红</td>
<td>红</td>
<td>浅红</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>品（洋）红</td>
<td>品（洋）红</td>
<td>浅品（洋）红</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>棕</td>
<td>棕</td>
<td>黄</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>白</td>
<td>白</td>
<td>亮白</td>
</tr>
</tbody>
</table>
<h2 id="指令"><a class="header-anchor" href="#指令">¶</a>指令</h2>
<table>
    <tr>
        <th align="center">指令</th>
        <th align="center">使用</th>
    </tr>
    <tr>
        <td>$和$$</td>
        <td>nasm特有<br/>$:当前行地址<br/>$$:当前所在段起始地址</td>
    </tr>
    <tr>
        <td rowspan="4">div(无符号除法)</td>
        <td>8位（寄存器或者8位操作数的内存地址）<br/> 除数在寄存器AX中<br/> 相除后：商在AL中，余数在AH中<br/>示例：<br/>&emsp;&emsp;div bh<br/>&emsp;&emsp;div byte [0x2002]</td>
    </tr>
    <tr>
        <td>16位（寄存器或者16位操作数的内存地址）<br/> 除数是32位的，低16位在AX中，高16位在DX中<br/>相除后：商在AX中，余数在DX中<br/>示例：<br/>&emsp;&emsp;div bx<br/>&emsp;&emsp;div word [0x2002]</td>
    </tr>
    <tr>
        <td>32位（寄存器或者32位操作数的内存地址）<br/> 除数是64位的，低32位在EAX中，高32位在EDX中<br/> 相除后：商在EAX中，余数在EDX中示例：<br/>&emsp;&emsp;div ebx<br/>&emsp;&emsp;div dword [0x2002]</td>
    </tr>
    <tr>
        <td>64位（寄存器或者64位操作数的内存地址）<br/>  除数是128位的，低64位在EAX中，高64位在RDX中<br/> 相除后：商在RAX中，余数在RDX中<br/>示例：<br/>&emsp;&emsp;div rbx<br/>&emsp;&emsp;div dword [0x2002]</td>
    </tr>
    <tr>
        <td>idiv（有符号除法）</td>
        <td>寄存器规则同div<br/>正负：如果被除数和除数符号相同，商为正数，否则商为负则为负数<br/>余数的符号始终和被除数相同</td>
    </tr>
    <tr>
        <td rowspan="4">mul(无符号乘法)</td>
        <td>8位寄存器或者8位操作数的内存地址）<br/> 被乘数是8位的，在寄存器AL中<br/> 相乘后，乘积是16位的，在寄存器AX中<br/>示例：<br/>&emsp;&emsp;mul bh<br/>&emsp;&emsp;mul byte [0x2002]</td>
    </tr>
    <tr>
        <td>16位（寄存器或者16位操作数的内存地址）<br/> 被乘数是16位的，在寄存器AX中<br/> 相除后：乘积是32位的，低16位在寄存器AX中，高16位在寄存器DX中<br/>示例:<br/>&emsp;&emsp;mul bx<br/>&emsp;&emsp;mul word [0x2002]</td>
    </tr>
    <tr>
        <td>32位（寄存器或者32位操作数的内存地址）<br/>被乘数是32位的，在寄存器AX中<br/>相除后：乘积是64位的，低32位在寄存器EAX中，高32位在寄存器EDX中<br/>示例：<br/>&emsp;&emsp;mul ebx<br/>&emsp;&emsp;mul dword [0x2002]</td>
    </tr>
    <tr>
        <td>64位（寄存器或者64位操作数的内存地址）被乘数是64位的，在寄存器RAX中<br/>相除后：乘积是128位的，低64位在寄存器RAX中，高64位在寄存器RDX中<br/>示例：<br/>&emsp;&emsp;mul rbx<br/>&emsp;&emsp;mul dword [0x2002]</td>
    </tr>
    <tr>
		<td>imul(无符号乘法)</td>
		<td>类似mul</td>
    </tr>
    <tr>
        <td rowspan="2">add, adc</td>
        <td>add:相加</td>
    </tr>
    <tr>
        <td>adc:进位相加，受进位标志CF影响</td>
    </tr>
    <tr>
        <td rowspan="2">or, xor</td>
        <td>or:或操作</td>
    </tr>
    <tr>
        <td>xor:异或指令<br/>可用于寄存器清`xor ax, ax,等价于mov ax 0,用异或操作的都是寄存器，速度会更快</td>
    </tr>
    <tr>
        <td rowspan="2">neg, not</td>
        <td>neg:求补码（取反）<br/>neg dx=> dx * -1<br/>等同-2=>2,  3=>-3</td>
    </tr>
    <tr>
        <td>not:逐位求反</td>
    </tr>
    <tr>
        <td rowspan="4">shr,ror,shl,rol</td>
        <td>shr:右移</td>
    </tr>
    <tr>
        <td>ror:循环右移</td>
    </tr>
    <tr>
        <td>shl:左移</td>
    </tr>
    <tr>
        <td>rol:循环左移</td>
    </tr>
    <tr>
        <td rowspan="2">near,for</td>
        <td>near:绝对间近跳转，寻址范围为64K</td>
    </tr>
    <tr>
        <td>jmp near table 近距离跳转</td>
    </tr>
    <tr>
        <td rowspan="2"> dec, inc</td>
        <td>dec：递减，i--</td>
    </tr>
    <tr>
        <td>inc：递增，i++</td>
    </tr>
    <tr>
        <td rowspan="2">rep，loop重复指令</td>
        <td>rep次数由cx寄存器决定(为0则停止)<br/>rep movsw（cx会自己递减）</td>
    </tr>
    <tr>
        <td>loop机器码E2，8位相对偏移量，也就意味着，跳转位置不能太远，循环次数也是由cx确定，为0则中断循环（cx会自己递减）</td>
    </tr>
    <tr>
        <td>movsb, movsw</td>
        <td>数据传输指令，只会传送一次，一般辅助循环指令使用<br/> 使用规则:<br/> DS:SI：原始数据串的段地址：偏移地址,si会自动改变值（根据方向递增或递减）<br/> ES:DI：目标位置的段地址：偏移地址，di会自动改变值（根据方向递增或递减）<br/> 设置传送方向：cld,std</td>
    </tr>
    <tr>
        <td rowspan="2">cld,std</td>
        <td>cld：FLAGS寄存器方向位（bit10）清零，此时传送方向，低地址向高地址传送</td>
    </tr>
    <tr>
        <td>sld：FLAGS寄存器方向位（bit10）置一，此时传送方向，高地址向低地址传送</td>
    </tr>
    <tr>
        <td rowspan="2">cli,sti</td>
        <td>cli:FLAGS寄存器方向位（bit9：IF）清零</td>
    </tr>
    <tr>
        <td>sti:FLAGS寄存器方向位（bit9：IF）置一</td>
    </tr>
    <tr>
        <td>SECTION，ALIGN，VSTART</td>
        <td>section给程序分段,align执行段的内存对齐方式，在同一个程序中，由多个段，理论每个段中的第一个数据地址是0，但是实际上是相对程序开头的地址，所以需要实现某个段的首个数据地址是0时，需要使用VSTART=0（0为指定起始地址，如果为2则每个段其实数据地址为2）<br/>示例：<br/>SECTION data1 ALIGN=16 VSTART=0<br/>&emsp;&emsp;mydata dw 0xFACE<br/>SECTION data2 ALIGN=16 VSTART=0<br/>&emsp;&emsp;string db 'hello'<br/>section code ALIGN=16 VSTART=0<br/>&emsp;&emsp;mov bx,mydata<br/>&emsp;&emsp;mov si,string</td>
    </tr>
    <tr>
        <td>section.段名字.start</td>
        <td>计算一个段相对整个程序的起始位置，相当于这个段位于程序开头的字节数，也可以是理解为相对程序开头的偏移量(示例见用户程序头部信息)</td>
    </tr>
    <tr>
        <td>equ</td>
        <td>等同于。常量的声明，类似于#define。常量的声明不会占用汇编地址</td>
    </tr>
    <tr>
        <td>resb，resw，resd</td>
        <td>在编译过程中保留指定大小的空间，不做初始化<br/>&emsp;&emsp;resb 256 == resw 128 == resd 64 == times 256 db 0</td>
    </tr>
    <tr>
        <td>in,out</td>
        <td>端口的输入输出不能直接使用mov指令，在intel中需要使用in，out;它们都不影响标志位<br/>in:源操作数通常是dx（存放端口号），目标操作数根据数据大小使用al或ax,当端口号小于256时，源操作数可以使用立即数<br/>out:目标操作数通常为dx或小于256的立即数，源操作数为al或ax（和in相反）</td>
    </tr>
    <tr>
        <td>call指令</td>
        <td>调用程序（16位相对近调用，所以跳转时cs不用压栈保存数据）。被调用的子程序可以ret或retf指令结尾，过程返回，以此返回主程序继续执行。ip指针寄存器指向下一条指令的偏移地址，调用前ip压栈，返回时出栈。<br/>&emsp;&emsp;call 标号或者目标处的汇编地址（16位相对近调用,前后两个字节的大小-32768到32767，可搭配ret）<br/>&emsp;&emsp;call 寄存器/偏移地址（段内，16位间接绝对近调用，可搭配ret）<br/>&emsp;&emsp;call cx:转移前先将ip压栈，然后用cx中的值填充ip，再进行跳转<br/>&emsp;&emsp;call [0x3000]:转移前将ip压栈，然后ds值左移4位加上偏移地址0x3000取到物理地址，在地址中取出一个字（两个字节），填充到ip，再进行跳转<br/>&emsp;&emsp;call [bx]:转移前将ip压栈，然后ds+bx得到物理地址，在地址中取出一个字（两个字节），填充到ip，再进行跳转<br/>call 16位段地址:16位偏移地址（16位直接绝对远调用,可搭配reft）<br/>&emsp;&emsp;call 0x052e:0x003c:转移前将ip压栈,0x052e替换cs内容，0x003c替换ip内容<br/>&emsp;&emsp;call far 目标地址(16位间接绝对远调用,可搭配reft)<br/>&emsp;&emsp;call far [0x2000]:转移前将cs,ip压栈,然后ds值左移4位加上偏移地址0x2000取到物理地址，在地址中取出两个个字（四个字节），前一个字填充到ip，后一个字填充到cs,再进行跳转<br/>&emsp;&emsp;call far [bx]:转移前将cs,ip压栈,然后ds+bx得到物理地址,在地址中取出两个个字（四个字节），前一个字填充到ip，后一个字填充到cs,再进行跳转</td>
    </tr>
    <tr>
        <td rowspan="3"> ret,retf</td>
        <td>ret 用栈中的数据修改IP（近转移）</td>
    </tr>
    <tr>
        <td>retf 用栈中数据修改cs：ip（远转移）</td>
    </tr>
    <tr>
    	<td><b>他们不一定要搭配call执行使用，也可搭配push使用，push先压缩段地址，在压缩偏移地址，然后调用retf，将从栈中pop出数据填充到cs和ip当中</b></td>
    </tr>
    <tr>
    	<td>iret</td>
        <td>所有的中断程序结尾<b>必须</b>是以iret指令结尾</td>
    </tr>
     <tr>
    	<td>iret</td>
         <td>所有的中断程序结尾<b>必须</b>是以iret指令结尾</td>
    </tr>
    <tr>
    	<td>test</td>
    	<td>test 寄存器/地址， 寄存器/立即数<br/>与and类似，不同于目标操作数的值不会被改变，但是FLAGS的值会改变</td>
    </tr>
    <tr>
    	<td>hlt</td>
    	<td>停止指令，使CPU进入低功耗状态，直到用中断唤醒</td>
    </tr>
    <tr>
    	<td rowspan="4">int, int3,into</td>
    	<td>int:软中断           int 中断号</td>
    </tr>
    <tr>
    	<td>int3:陷阱中断（调式程序使用，断点的原理）     int3 中断号</td>
    </tr>
    <tr>
    	<td>into:溢出中段（OF是1时发生into中断）</td>
    </tr>
    <tr>
    	<td>int 0x70：这里的0x70中断等同于实时时钟发出的0x70中断<br/>int3 != int（space） 3</td>
    </tr>
    <tr>
    	<td> 条件跳转</td>
    	<td>js:符号标志SF为1则转移，jns,符号标志为0则转移;<br/>jz:零标志ZF为1则转移，jnz:零标志ZF为0则转移;<br/>jo:溢出标志OF为1则转移，jno:溢出标志OF为0则转移;<br/>jc:进位标志CF为1则转移，jnc:进位标志CF为0则转移;<br/>jp:奇偶标志PF为1则转移，jnp:奇偶标志PF为0则转移;<br/> jcxz:当CX寄存器内容为0时则转移;<br/>cmp,比较两个数后，条件转移（大于等于小于等等）<br/>&emsp;&emsp;助记:<br/>&emsp;&emsp;&emsp;&emsp;a:above高于<br/>&emsp;&emsp;&emsp;&emsp;b:below低于<br/>&emsp;&emsp;&emsp;&emsp;e:equal相等<br/>&emsp;&emsp;&emsp;&emsp;n:not不<br/>&emsp;&emsp;&emsp;&emsp;g:greater大于<br/>&emsp;&emsp;&emsp;&emsp;l:小于<br/>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;例子：jnge:不大于等于</td>
    </tr>
    <tr>
        <td> 无条件转移（jmp）</td>
        <td>jmp 之后的指令如果跟了 ret，那就直接退出到上一个 call 对应指令的下一行;jmp跳转后会影响cs，ip的值，但不会影响ds,es的值<br/>jmp short 标号/目标处的汇编地址(段内，相对短转移，前后一个字节的大小-128到127)<br/>jmp near 标号/目标处的汇编地址（段内，相对近转移，前后两个字节的大小-32768到32767）<br/>jmp 标号/目标处的汇编地址（编译器决定时short还是near）<br/>jmp 寄存器/内存地址（段内，16位间接绝对近转移）<br/>jmp 16位段地址:16位偏移地址 （段之间转移，16位直接绝对远转移）<br/>示例：<br/>&emsp;&emsp;jmp 0x052e:0x003c:0x052e替换cs内容，0x003c替换ip内容<br/>&emsp;&emsp;jmp far 内存地址（16位间接绝对远转移）<br/>示例：<br/>&emsp;&emsp;jmp far [0x2002]:2002~2003替换ip内容，2004~2005替换cs内容<br/>&emsp;&emsp;jmp far [bx]:ds+bx拿到物理地址中数据中的两个字，第一个字替换ip内容，第二个字替换cs内容</td>
    </tr>
    </table>
<h2 id="指令对flags寄存器的影响"><a class="header-anchor" href="#指令对flags寄存器的影响">¶</a>指令对flags寄存器的影响</h2>
<ul>
<li>cbw / cwde / cdqe / cwd / cdq/ cqo: 不影响任何标志位。</li>
<li>cld  :  DF=0,对CF、OF、ZF、SF、AF和PF的影响未定义。</li>
<li>std :  DF=1,不影响其他标志位。</li>
<li>inc/dec: CF标志不受影响;对OF、SF、ZF、AF和PF的影响依计算结果而定。</li>
<li>add / sub:OF、SF、ZF、AF、CF和PF的状态依计算结果而定。</li>
<li>div / idiv：对CF、OF、SF、ZF、AF和PF的影响未定义。</li>
<li>mov / movs：<strong>这类指令不影响任何标志位。</strong></li>
<li>neg:如果操作数为0，则CF=0，否则CF=1;对OF、SF、ZF、AF和PF的影响,计算结果而定。</li>
<li>xor:OF=0,CF=O;对SF、ZF和PF依计算结果而定;对AF的影响未定义。</li>
</ul>
<h2 id="寻址方式"><a class="header-anchor" href="#寻址方式">¶</a>寻址方式</h2>
<h3 id="寄存器寻址"><a class="header-anchor" href="#寄存器寻址">¶</a>寄存器寻址</h3>
<blockquote>
<p>操作数时由寄存器引起的</p>
</blockquote>
<ul>
<li>mov ax, cx</li>
<li>add bx, 0xf000(目标操作数)</li>
<li>inc dx</li>
</ul>
<h3 id="立即数寻址"><a class="header-anchor" href="#立即数寻址">¶</a>立即数寻址</h3>
<blockquote>
<p>操作数时由立即数直接指定的</p>
</blockquote>
<ul>
<li>add bx, 0xf000(源操作数)</li>
<li>mov dx, mydata</li>
</ul>
<h3 id="内存寻址"><a class="header-anchor" href="#内存寻址">¶</a>内存寻址</h3>
<blockquote>
<p>数据在内存当中（8086：段地址左移4位加上偏移地址形成20位的物理地）</p>
<p>段地址：由4个段寄存器之一提供（cs, ds,es,ss,默认ds）,偏移地址：由指令来提供（内存寻址，实际即使寻找偏移地址）</p>
</blockquote>
<ul>
<li>直接内存寻址：
<ul>
<li>mov ax, [0x5c0f]</li>
<li>add word [0x0230], 0x5000(目标操作数)</li>
<li>xor byte [es:mydata], 0x55(目标操作数)</li>
</ul>
</li>
<li>变址寻址：内存寻址的一种
<ul>
<li>类似基址寻址，不同之处主要在于变址寻址是使用si和di索引寄存器</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 使用变址寻址的例子</span><br><span class="line"></span><br><span class="line">mov [si],dx</span><br><span class="line">add ax,[di]</span><br><span class="line">xor word [si], 0x8000 ; si提供偏移地址时，默认使用ds提供段地址</span><br><span class="line"></span><br><span class="line">mov [si+0x100], al; 8086允许变址寄存器和基址寄存器加上偏移量使用</span><br><span class="line">and byte [di+mydata], 0x80 ; and 位相与</span><br></pre></td></tr></table></figure>
<h3 id="基址寻址"><a class="header-anchor" href="#基址寻址">¶</a>基址寻址</h3>
<blockquote>
<p>在8086中由基址寄存器bx,bp提供,基址地址也称有效地址（effective address）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	buffer dw 0x20, 0x100, 0x0f,0x300, 0xff00(buffer是标号)</span><br><span class="line">; 以下使用直接寻址方式将所有数据加一</span><br><span class="line"></span><br><span class="line">	inc word [buffer]</span><br><span class="line">	inc word [buffer+2]</span><br><span class="line">	inc word [buffer+4]</span><br><span class="line">	inc word [buffer+6]</span><br><span class="line">	inc word [buffer+8]</span><br><span class="line"></span><br><span class="line">; 以下使用基址寻址方式将所有数据加一</span><br><span class="line">	mov bx, buffer</span><br><span class="line">	mov cx, 5</span><br><span class="line">lpinc:</span><br><span class="line">	inc word, [bx]</span><br><span class="line">	add bx, 2</span><br><span class="line">	loop ipinc</span><br><span class="line">	</span><br><span class="line">; 越过出栈操作，把栈当作普通段访问</span><br><span class="line">	mov ax, 0x5000</span><br><span class="line">	mov bx, 0x7000</span><br><span class="line">	mov cx, 0x8000</span><br><span class="line">	push ax</span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">	</span><br><span class="line">	mov bx, sp ; bx指向栈底</span><br><span class="line">	mov dx, [ss:bx+2] ; bx+2：8086允许基址寄存器加一个偏移量，不会影响bx和sp的值，只是形成一个和</span><br><span class="line">	pop ax ; 出栈用哪个寄存器来接受没有限制</span><br><span class="line">	pop bx</span><br><span class="line">	pop cx ; 维持栈平衡（压多少，出多少）</span><br><span class="line">	</span><br><span class="line">; bp基址寄存器的使用</span><br><span class="line">	mov ax, 0x5000</span><br><span class="line">	mov bx, 0x7000</span><br><span class="line">	mov cx, 0x8000</span><br><span class="line">	push ax</span><br><span class="line">	push bx</span><br><span class="line">	push cx</span><br><span class="line">	</span><br><span class="line">	mov bp, sp</span><br><span class="line">	mov dx, [bp+2] ; bp提供偏移，默认使用ss段寄存器提供段地址，所以可以省略段超越前缀ss:([ss:bp+2])</span><br><span class="line">	pop ax</span><br><span class="line">	pop bx</span><br><span class="line">	pop cx</span><br></pre></td></tr></table></figure>
<h3 id="基址变址寻址"><a class="header-anchor" href="#基址变址寻址">¶</a>基址变址寻址:</h3>
<blockquote>
<p>基址变址寻址中使用了bx时，默认使用ds提供段地址，访问数据段;使用了bp时，默认使用ss提供段地址，访问栈段(使用示例见示例代码<strong>基址变址寻址的使用</strong>项中)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[bx + si]</span><br><span class="line">[bx + di]</span><br><span class="line">[bx + si + 偏移量]</span><br><span class="line">[bx + di + 偏移量]</span><br><span class="line"></span><br><span class="line">[bp + si]</span><br><span class="line">[bp + di]</span><br><span class="line">[bp + si + 偏移量]</span><br><span class="line">[bp + di + 偏移量]</span><br><span class="line"></span><br><span class="line">mov ax, [bx + si + 0x03]</span><br></pre></td></tr></table></figure>
<h2 id="用户程序"><a class="header-anchor" href="#用户程序">¶</a>用户程序</h2>
<ul>
<li>用户程序头部必须包含：程序的长度，入口点，段重定位表项数，段重定位表</li>
<li>用户程序起始逻辑扇区号从100开始存放（协定）</li>
</ul>
<h2 id="设备交互"><a class="header-anchor" href="#设备交互">¶</a>设备交互</h2>
<blockquote>
<p>每个外部设备都有自己的ROM，里面有设备提供的调用例程代码。</p>
<p>ROM映射到C0000~E0000之间，bios把他们的中断程序写入到中断向量表中(IVT)。</p>
<p>外部设备接口（板卡）设计：</p>
<table>
<thead>
<tr>
<th>字节一</th>
<th>字节二</th>
<th>字节三</th>
<th>…</th>
</tr>
</thead>
<tbody>
<tr>
<td>55</td>
<td>AA</td>
<td>ROM中代码长度(以512为长度)</td>
<td>功能调用例程代码</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="硬盘（块设备）"><a class="header-anchor" href="#硬盘（块设备）">¶</a>硬盘（块设备）</h3>
<ul>
<li>扇区时硬盘的基本单位，和cpu交互数据时是按一个扇区一个扇区的交互</li>
<li>个人计算机上硬盘分配了8个端口<strong>0x1f0~0x1f7</strong></li>
</ul>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>固定值1</td>
<td>0：CHS模式；<br />1：LBA模式</td>
<td>固定值1</td>
<td>0：主硬盘；<br />1：从硬盘</td>
<td>逻辑扇区号位27</td>
<td>逻辑扇区号位26</td>
<td>逻辑扇区号位25</td>
<td>逻辑扇区号位24</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>BSY:为1则表示硬盘忙</td>
<td></td>
<td></td>
<td></td>
<td>DRQ：为1表明硬盘已准备好与主机交换数据</td>
<td></td>
<td></td>
<td>ERR：为1则表明前一个命令执行错误。具体原因可访问端口0x1f1</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; LBA28读数据</span><br><span class="line">;第一步：告诉硬盘要操作的扇区数</span><br><span class="line">mov dx, 0x1f2</span><br><span class="line">mov al, 0x01;需要操作一个扇区，如果这个数字是0，非常特殊，它代表要读写256个扇区</span><br><span class="line">out dx, al</span><br><span class="line"></span><br><span class="line">;第二步：设置起始LBA号</span><br><span class="line">;扇区号=0000 00000000 00000000 00000010（28位）</span><br><span class="line">mov dx, 0x1f3</span><br><span class="line">mov al, 0x02</span><br><span class="line">out dx, al		;LBA地址7~0</span><br><span class="line">inc dx			;0x1f4</span><br><span class="line">mov al, 0x00</span><br><span class="line">out dx,al		;LBA地址15~8</span><br><span class="line">inc dx			;0x1f5</span><br><span class="line">out dx,al		;LBA地址23~16</span><br><span class="line">inc dx			;0x1f6</span><br><span class="line">mov al,0xe0		;LBA模式，主硬盘，LBA27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;第三步：告诉硬盘读命令</span><br><span class="line">mov dx,0x1f7	;0x1f7命令端口和断开端口</span><br><span class="line">mov al, 0x20;读命令</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">;第四步:等待读写操作完成</span><br><span class="line">mov dx,0x1f7</span><br><span class="line">.waits:</span><br><span class="line">	in al,dx</span><br><span class="line">	and al,0x88</span><br><span class="line">	cmp al,0x08</span><br><span class="line">	jnz .waits	;不忙，且硬盘已经准备好数据传输</span><br><span class="line">	</span><br><span class="line">;第五步：连续读出数据</span><br><span class="line">;假定DS已指向存放扇区数据的段，BX里是段内偏移地址</span><br><span class="line">mov cx,256		;总共要读取的字数</span><br><span class="line">mov dx,0x1f0</span><br><span class="line">.readw:</span><br><span class="line">	in ax,dx</span><br><span class="line">	mov [bx],ax</span><br><span class="line">	add bx,2</span><br><span class="line">	loop .readw</span><br></pre></td></tr></table></figure>
<h3 id="显卡"><a class="header-anchor" href="#显卡">¶</a>显卡</h3>
<blockquote>
<p>显卡提供两个端口<code> 0x3d4</code>(索引端口)， <code>0x3d5</code>(数据端口)，显卡内部寄存器都有自己的编号，其中两个8位光标寄存器为0x0e（高8位）,0x0f（低8位）.</p>
<p>当我们把0x0f给索引端口时，数据端口会连接0x0f寄存器，我们就可以通过数据端口去读写数据。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">put_char: ;显示一个字符</span><br><span class="line">    ;输入：cl=字符ascii</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    ;以下取当前光标位置</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    in al,dx ;高8位</span><br><span class="line">    mov ah,al</span><br><span class="line"></span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    in al,dx ;低8位</span><br><span class="line">    mov bx,ax ;BX=代表光标位置的16位数</span><br><span class="line"></span><br><span class="line">    cmp cl,0x0d ;回车符？</span><br><span class="line">    jnz .put_0a ;不是。看看是不是换行等字符</span><br><span class="line">    mov ax,bx ;此句略显多余，但去掉后还得改书，麻烦</span><br><span class="line">    mov bl,80</span><br><span class="line">    div bl</span><br><span class="line">    mul bl</span><br><span class="line">    mov bx,ax</span><br><span class="line">    jmp .set_cursor</span><br><span class="line"></span><br><span class="line">.put_0a:</span><br><span class="line">    cmp cl,0x0a ;换行符？</span><br><span class="line">    jnz .put_other ;不是，那就正常显示字符</span><br><span class="line">    add bx,80</span><br><span class="line">    jmp .roll_screen</span><br><span class="line"></span><br><span class="line">    .put_other: ;正常显示字符</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov es,ax</span><br><span class="line">    shl bx,1</span><br><span class="line">    mov [es:bx],cl</span><br><span class="line"></span><br><span class="line">    ;以下将光标位置推进一个字符</span><br><span class="line">    shr bx,1</span><br><span class="line">    add bx,1</span><br><span class="line"></span><br><span class="line">.roll_screen:</span><br><span class="line">    cmp bx,2000 ;光标超出屏幕？滚屏</span><br><span class="line">    jl .set_cursor</span><br><span class="line"></span><br><span class="line">	push bx</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    cld</span><br><span class="line">    mov si,0xa0</span><br><span class="line">    mov di,0x00</span><br><span class="line">    mov cx,1920</span><br><span class="line">    rep movsw</span><br><span class="line">    mov bx,3840 ;清除屏幕最底一行</span><br><span class="line">    mov cx,80</span><br><span class="line">.cls:</span><br><span class="line">    mov word[es:bx],0x0720</span><br><span class="line">    add bx,2</span><br><span class="line">    loop .cls</span><br><span class="line"></span><br><span class="line">    pop bx</span><br><span class="line">    sub bx,80</span><br><span class="line"></span><br><span class="line">.set_cursor:</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    mov al,bh</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    mov al,bl</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line">    pop dx</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h3 id="8259芯片"><a class="header-anchor" href="#8259芯片">¶</a>8259芯片</h3>
<blockquote>
<p>含有：中断屏蔽寄存器，中断服务寄存器</p>
</blockquote>
<ul>
<li>
<p>8259主片:</p>
<ul>
<li>INC：与处理器的INTR相连</li>
<li>引脚：0x08~0x0F</li>
<li>端口：<strong>0x20,0x21</strong></li>
<li>0x08(bit0):与系统定时器/计数器相连</li>
</ul>
</li>
<li>
<p>8259从片：</p>
<ul>
<li>INC：与主片的0x0A引脚相连</li>
<li>引脚：0x70~0x77</li>
<li>端口：<strong>0xA0,0xA1</strong></li>
<li>0x70(bit0)：与RTC相连,bit0是RTC的中断信号（0：不屏蔽；1：屏蔽中断）</li>
</ul>
</li>
<li>
<p>中断程序结束前需要发送中断结束命令（EOI），由服务寄存器处理</p>
</li>
</ul>
<h3 id="实时时钟（Real-Time-Clock-RTC）"><a class="header-anchor" href="#实时时钟（Real-Time-Clock-RTC）">¶</a>实时时钟（Real Time Clock:RTC）</h3>
<blockquote>
<p>它结合CMOS RAM使用;</p>
<p>RTC与系统总线相连的端口有<strong>索引端口：0x70/0x74;数据端口：0x71/0x75</strong></p>
<p>示例：示例代码中<code>RTC周期中断,显示时间</code></p>
</blockquote>
<ul>
<li>CMOS RAM内容分布</li>
</ul>
<table>
<thead>
<tr>
<th>偏移地址</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>秒</td>
</tr>
<tr>
<td>0x01</td>
<td>闹钟秒</td>
</tr>
<tr>
<td>0x02</td>
<td>分</td>
</tr>
<tr>
<td>0x03</td>
<td>闹钟分</td>
</tr>
<tr>
<td>0x04</td>
<td>时（bit7为0:12小时制；bit7为1:24小时制）</td>
</tr>
<tr>
<td>0x05</td>
<td>闹钟时</td>
</tr>
<tr>
<td>0x06</td>
<td>星期</td>
</tr>
<tr>
<td>0x07</td>
<td>日</td>
</tr>
<tr>
<td>0x08</td>
<td>月</td>
</tr>
<tr>
<td>0x09</td>
<td>年</td>
</tr>
<tr>
<td>0x0A</td>
<td>寄存器A</td>
</tr>
<tr>
<td>0x0B</td>
<td>寄存器B</td>
</tr>
<tr>
<td>0x0C</td>
<td>寄存器C</td>
</tr>
<tr>
<td>0x0D</td>
<td>寄存器D</td>
</tr>
</tbody>
</table>
<ul>
<li>BCD</li>
</ul>
<blockquote>
<p>CMOS RAM内容数值由二进制形式的十进制编码(Binary Coded Decimal)填写</p>
<p>示例：</p>
<p>25：二进制编码：0001 1001</p>
<pre><code>  	BCD编码：0010 0101（拆解位2和5，拆解的数字不能大于9，否则视为无效）
</code></pre>
</blockquote>
<h4 id="中断信号"><a class="header-anchor" href="#中断信号">¶</a>中断信号</h4>
<ul>
<li>寄存器C是只读寄存器</li>
</ul>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>比特位</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器A</td>
<td>bit7</td>
<td>UIP（Update In Process）：更新过程指示。（0：更新周期至少在488us内不会启动，此时访问cmos中内容的时间时安全的，1：488us内启动，周期不会超过1984us）</td>
</tr>
<tr>
<td>寄存器A</td>
<td>6~4</td>
<td>RTC时基选择。这3位控制外部输入频率的功能。系统将其初始化到010，为RTC选择一个32.768kHz的时钟频率。</td>
</tr>
<tr>
<td>寄存器A</td>
<td>3~0</td>
<td>RTC速率选择（Rate Select,RS）。选择分频电路的分节点。此处的选择决定了<strong>周期性中断信号发生的时间间隔</strong>。若选择0000，表示不产生周期性中断信号。注意：这是时基为32.768kHz的情况，使用其他时基的速率请参考相关资料<a href="E:%5CBook%5Cbooktool%5C%E7%9B%B8%E5%85%B3%E6%95%99%E7%A8%8B%5CMC146818.pdf">MC146818.pdf</a>。<br />0000:从不触发中断<br />0001:3.90625ms<br />0010:7.8125ms<br />0011:122.070us<br />0100:244.141us<br />0101:488.281us<br />0110:976.5625us<br />0111:1.953125ms<br />1000:3.90625ms<br />1001:7.8125ms<br />1010:5.625ms<br />1011:1.25ms<br />1100:62.5ms<br />1101:125ms<br />1110:250ms<br />1111:5000ms(最长一秒2次)</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit0</td>
<td>DSLSWS(Daylight Savings Legacy Software Support):老软件的夏令时支持（兼容老设备，现已不适用）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit1</td>
<td>HF(Hour Format):小时模式（0：12小时制；1：24小时制）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit2</td>
<td>DM(Data Mode):数据模式（0：BCD编码；1：二进制编码）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit3</td>
<td>SQWE(Square Wave Enable):方波输出允许（兼容老芯片，现已不适用）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit4</td>
<td>UIE(Update-ended Interrupt Enabele):更新周期结束中断允许（0：不产生<strong>更新周期中断信号</strong>，1反之）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit5</td>
<td>AIE(Alarm Interrupt Enable):<strong>闹钟中断是否允许</strong>（0：不允许，1：允许）</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit6</td>
<td>PIE（Periodic Interrupt Enable）:<strong>周期性中断</strong>是否允许发生（0：不允许；1：允许）<br />寄存器A选择0000时，PIE自动置0</td>
</tr>
<tr>
<td>寄存器B</td>
<td>bit7</td>
<td>SET:<strong>更新周期</strong>禁止（0：更新周期，每秒都发生；1：终止更新周期，并且此后不再产生更新周期。）</td>
</tr>
<tr>
<td>寄存器C</td>
<td>0~3</td>
<td>保留位：始终为0</td>
</tr>
<tr>
<td>寄存器C</td>
<td>bit4</td>
<td>UF(Update-enable Flag):更新结束标志（1：发生；0：没有发生）</td>
</tr>
<tr>
<td>寄存器C</td>
<td>bit5</td>
<td>AF(Alarm Flag):闹钟中断标志（1：发生；0：没有发生）</td>
</tr>
<tr>
<td>寄存器C</td>
<td>bit6</td>
<td>PF(Periodic Interrupt Flag):周期性中断标志（1：发生；0：没有发生）</td>
</tr>
<tr>
<td>寄存器C</td>
<td>bit7</td>
<td>IRQF(Interrupt Request Flag):中断请求标志（1：有中断发生，0：没有中断发生）<br />当为1时去检查bit4~6是那种中断发生，为IRQF都取会使IRQF清0</td>
</tr>
</tbody>
</table>
<h2 id="中断"><a class="header-anchor" href="#中断">¶</a>中断</h2>
<blockquote>
<p>NMI:不可屏蔽中断</p>
<p>INTR：可屏蔽中断</p>
</blockquote>
<h3 id="中断向量表（Interrupt-Vector-Table：IVT）"><a class="header-anchor" href="#中断向量表（Interrupt-Vector-Table：IVT）">¶</a>中断向量表（Interrupt Vector Table：IVT）</h3>
<blockquote>
<p>实模式下，cpu可以识别256个中断，共1KB大小（00000~003FF）</p>
<p>表示由基础输入输出系统系统（BIOS）启动时创建的，xp /512xh 0(0x7c00后执行可查看IVT)</p>
<p>格式：(中断号*4便可获得入口地址)</p>
<p>00000~00001：中断0的入口地址的偏移地址</p>
<p>00002~00003：中断0的入口地址的段地址</p>
<p>00004~00005：中断0的入口地址的偏移地址</p>
<p>00006~00007：中断0的入口地址的段地址</p>
<p>…</p>
<p>…</p>
</blockquote>
<h3 id="无法发生中断的时期"><a class="header-anchor" href="#无法发生中断的时期">¶</a>无法发生中断的时期</h3>
<blockquote>
<p>当有命令修改ss栈段寄存器时，这条指令执行及下条指令（所以此处一般后面应该修改sp寄存器）执行时不允许发生中断</p>
</blockquote>
<h3 id="中断类别"><a class="header-anchor" href="#中断类别">¶</a>中断类别</h3>
<h4 id="硬件中断"><a class="header-anchor" href="#硬件中断">¶</a>硬件中断</h4>
<blockquote>
<p>来自处理器外部的中断（键盘，实时时钟）</p>
</blockquote>
<h4 id="内部中断"><a class="header-anchor" href="#内部中断">¶</a>内部中断</h4>
<blockquote>
<p>来自处理器内部的中断，不受IF的影响，出现会立即执行</p>
</blockquote>
<h4 id="软中断"><a class="header-anchor" href="#软中断">¶</a>软中断</h4>
<blockquote>
<p>编写程序时用指令(int,int3,into)指定的中断,不收IF的影响</p>
</blockquote>
<h3 id="中断处理过程"><a class="header-anchor" href="#中断处理过程">¶</a>中断处理过程</h3>
<ul>
<li>第一步：保护断点的现场</li>
</ul>
<blockquote>
<p>将标志寄存器，断码段寄存器cs,指针寄存器ip及相关寄存器压栈</p>
</blockquote>
<ul>
<li>第二部：执行中断处理程序</li>
</ul>
<blockquote>
<p>此时把拿到的中断号*4拿到程序地址，继而执行</p>
</blockquote>
<ul>
<li>第三步：在遇到iret指令时，相关寄存器出栈，返回断点接着执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外部中断--&gt;8259A----&gt;IF(可中断，发送中断响应，要求8259A发送一个中断号)--&gt;8259A--&gt;中断处理过程</span><br><span class="line"></span><br><span class="line">内部中断-----------------------&gt;中断处理过程</span><br><span class="line">										</span><br><span class="line">软中断-------------------------&gt;中断处理过程</span><br></pre></td></tr></table></figure>
<h3 id="BIOS中断调用"><a class="header-anchor" href="#BIOS中断调用">¶</a>BIOS中断调用</h3>
<blockquote>
<p>call调用指令必要要知道段地址和偏移地址，但是先调用偏移地址的功能时将拿不到地址（因为版本更新，地址也会一直变化），所以此时的设计就是用中断代替call去提供系统服务</p>
</blockquote>
<ul>
<li>示例一</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov ah,0	;每个中段有很多功能，发送软中断前，将0号功能写入ah</span><br><span class="line">int 0x16	;需要参数的功能得参考bois功能调用表获取参数存放的寄存器</span><br></pre></td></tr></table></figure>
<h2 id="示例代码"><a class="header-anchor" href="#示例代码">¶</a>示例代码</h2>
<h3 id="1-2-3…-100"><a class="header-anchor" href="#1-2-3…-100">¶</a>1+2+3…+100</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmp start</span><br><span class="line"></span><br><span class="line">message:</span><br><span class="line">    db &#x27;1+2+3+...+100=&#x27; ;等同于db &#x27;1&#x27;,&#x27;+&#x27;,&#x27;2&#x27;,&#x27;+&#x27;,.....&#x27;=&#x27;</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov ax, 0x7c0</span><br><span class="line">    mov ds, ax</span><br><span class="line"></span><br><span class="line">    mov ax, 0xb800</span><br><span class="line">    mov es, ax</span><br><span class="line"></span><br><span class="line">    mov si, message</span><br><span class="line">    xor di, di</span><br><span class="line">    mov cx, start - message</span><br><span class="line"></span><br><span class="line">showmsg:</span><br><span class="line">    mov al, [si]</span><br><span class="line">    mov [es:di], al</span><br><span class="line">    inc di</span><br><span class="line">    mov byte [es:di], 0x07</span><br><span class="line">    inc di</span><br><span class="line">    inc si</span><br><span class="line">    loop showmsg</span><br><span class="line"></span><br><span class="line">    xor ax, ax</span><br><span class="line">    mov cx, 1</span><br><span class="line"></span><br><span class="line">summate:</span><br><span class="line">    add ax, cx</span><br><span class="line">    inc cx</span><br><span class="line">    cmp cx, 100</span><br><span class="line">    jle summate</span><br><span class="line"></span><br><span class="line">    xor cx, cx</span><br><span class="line">    mov ss, cx</span><br><span class="line">    mov sp, cx</span><br><span class="line"></span><br><span class="line">    mov bx, 10</span><br><span class="line">decompo:</span><br><span class="line">    inc cx</span><br><span class="line">    xor dx, dx</span><br><span class="line">    div bx</span><br><span class="line">    add dl, 0x30</span><br><span class="line">    push dx</span><br><span class="line">    cmp ax, 0</span><br><span class="line">    jne decompo</span><br><span class="line"></span><br><span class="line">shownum:</span><br><span class="line">    pop dx</span><br><span class="line">    mov [es:di], dl</span><br><span class="line">    inc di</span><br><span class="line">    mov byte [es:di], 0x07</span><br><span class="line">    inc di</span><br><span class="line">    loop shownum</span><br><span class="line"></span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55, 0xaa</span><br></pre></td></tr></table></figure>
<h3 id="基址变址寻址的使用"><a class="header-anchor" href="#基址变址寻址的使用">¶</a>基址变址寻址的使用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 使用基址变址寻址就地反转字母，而不适用栈</span><br><span class="line">jmp start</span><br><span class="line">string db &#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span><br><span class="line">start:</span><br><span class="line">	mov ax, 0x7c0</span><br><span class="line">	mov ds, ax</span><br><span class="line">	</span><br><span class="line">	mov bx,string			;数据区首地址</span><br><span class="line">	mov si,0				;正向索引</span><br><span class="line">	mov di,start-string-1	;方向索引</span><br><span class="line">	</span><br><span class="line">rever:</span><br><span class="line">	mov ah,[bx+si]</span><br><span class="line">	mov al,[bx+di]</span><br><span class="line">	mov [bx+di],al</span><br><span class="line">	mov [bx+si],ah			;首尾交换</span><br><span class="line">	inc si</span><br><span class="line">	dec di</span><br><span class="line">	cmp si,di</span><br><span class="line">	jl rever</span><br></pre></td></tr></table></figure>
<h3 id="用户程序头部信息"><a class="header-anchor" href="#用户程序头部信息">¶</a>用户程序头部信息</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 包含代码段、数据段和栈段的用户程序</span><br><span class="line"></span><br><span class="line">;=======================================================================</span><br><span class="line">section header vstart=0                         ;用户程序头部段</span><br><span class="line">    ;程序总长度[0x00]</span><br><span class="line">program_length:</span><br><span class="line">    dd  program_end</span><br><span class="line">    </span><br><span class="line">    ;用户程序入口点</span><br><span class="line">code_entry:</span><br><span class="line">    dw  start                                   ;偏移地址[0x40]</span><br><span class="line">    dd  section.code.start                      ;段地址[0x06]</span><br><span class="line"></span><br><span class="line">    ;段重定位表项个数[0x0A]</span><br><span class="line">realloc_tbl_len:</span><br><span class="line">    dw  (segtbl_end-segtbl_begin)/4</span><br><span class="line"></span><br><span class="line">    ;段重定位表</span><br><span class="line">segtbl_begin:</span><br><span class="line">    code_segment    dd  section.code.start      ;[0x0c]</span><br><span class="line">    data_segment    dd  section.data.start      ;[0x19]</span><br><span class="line">    stack_segment   dd  section.stack.start     ;[0x14]</span><br><span class="line">segtbl_end:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;=======================================================================</span><br><span class="line">section code align=16 vstart=0                  ;代码段</span><br><span class="line">start:</span><br><span class="line">    ;初始化执行时，DS和ES指向用户程序头部段</span><br><span class="line">    mov ax,[stack_segment]                      ;设置到用户程序自己的堆栈</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,stack_pointer                        ;设置初始的栈顶指针</span><br><span class="line"></span><br><span class="line">    mov ax,[data_segment]                       ;设置到用户程序自己的数据段</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov es,ax</span><br><span class="line">    </span><br><span class="line">    mov si,message</span><br><span class="line">    mov di,0</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">    mov al,[si]</span><br><span class="line">    cmp al,0</span><br><span class="line">    je exit</span><br><span class="line"></span><br><span class="line">    mov byte [es:di],al</span><br><span class="line">    mov byte [es:di+1],0x07</span><br><span class="line">    inc si</span><br><span class="line">    add di,2</span><br><span class="line">    jmp next</span><br><span class="line"></span><br><span class="line">exit:</span><br><span class="line">    jmp $</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;=======================================================================</span><br><span class="line">section data align=16 vstart=0                  ;数据段</span><br><span class="line">message:</span><br><span class="line">    db &#x27;hello world.&#x27;,0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;=======================================================================</span><br><span class="line">section stack align=16 vstart=0</span><br><span class="line">    resb 256</span><br><span class="line">stack_pointer:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;=======================================================================</span><br><span class="line">section trail align=16</span><br><span class="line">program_end:</span><br><span class="line"></span><br><span class="line">;bochsrc</span><br><span class="line">;###############################################################</span><br><span class="line">;# Configuration file for Bochs</span><br><span class="line">;###############################################################</span><br><span class="line">;</span><br><span class="line">;# how much memory the emulated machine will have</span><br><span class="line">;megs: 32</span><br><span class="line">;</span><br><span class="line">;# filename of ROM images</span><br><span class="line">;romimage: file=/usr/share/bochs/BIOS-bochs-latest</span><br><span class="line">;vgaromimage: file=/usr/share/bochs/VGABIOS-lgpl-latest</span><br><span class="line">;</span><br><span class="line">;# what disk images will be used</span><br><span class="line">;# floppya: 1_44=app.img, status=inserted</span><br><span class="line">;</span><br><span class="line">;# choose the boot disk.</span><br><span class="line">;boot:disk</span><br><span class="line">;</span><br><span class="line">;# where do we send log messages?</span><br><span class="line">;# log: bochsout.txt</span><br><span class="line">;</span><br><span class="line">;# disable the mouse</span><br><span class="line">;mouse: enabled=1</span><br><span class="line">;</span><br><span class="line">;# enable key mapping, using US layout as default.</span><br><span class="line">;# keyboard_mapping: enabled=1, map=/usr/share/bochs/keymaps/x11-pc-us.map</span><br><span class="line">;</span><br><span class="line">;# 硬盘设置</span><br><span class="line">;ata0-master: type=disk, path=&quot;app.img&quot;, mode=flat, cylinders=2, heads=16, spt=63</span><br></pre></td></tr></table></figure>
<h3 id="硬盘主引导扇区代码（加载程序）"><a class="header-anchor" href="#硬盘主引导扇区代码（加载程序）">¶</a>硬盘主引导扇区代码（加载程序）</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;文件说明：硬盘主引导扇区代码（加载程序）</span><br><span class="line"></span><br><span class="line">app_lba_start equ 100 ;声明常数（用户程序起始逻辑扇区号）</span><br><span class="line">;常数的声明不会占用汇编地址</span><br><span class="line"></span><br><span class="line">SECTION mbr align=16 vstart=0x7c00</span><br><span class="line">    ;设置堆栈段和栈指针</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,ax</span><br><span class="line"></span><br><span class="line">    mov ax,[cs:phy_base] ;计算用于加载用户程序的逻辑段地址</span><br><span class="line">    mov dx,[cs:phy_base+0x02]</span><br><span class="line">    mov bx,16</span><br><span class="line">    div bx</span><br><span class="line">    mov ds,ax ;令DS和ES指向该段以进行操作</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    ;以下读取程序的起始部分</span><br><span class="line">    xor di,di</span><br><span class="line">    mov si,app_lba_start ;程序在硬盘上的起始逻辑扇区号</span><br><span class="line">    xor bx,bx ;加载到DS:0x0000处</span><br><span class="line">    call read_hard_disk_0</span><br><span class="line"></span><br><span class="line">    ;以下判断整个程序有多大</span><br><span class="line">    mov dx,[2]</span><br><span class="line">    mov ax,[0]</span><br><span class="line">    mov bx,512 ;512字节每扇区</span><br><span class="line">    div bx</span><br><span class="line">    cmp dx,0</span><br><span class="line">    jnz @1 ;未除尽，因此结果比实际扇区数少1</span><br><span class="line">    dec ax ;已经读了一个扇区，扇区总数减1</span><br><span class="line">@1:</span><br><span class="line">    cmp ax,0 ;考虑实际长度小于等于512个字节的情况</span><br><span class="line">    jz direct</span><br><span class="line"></span><br><span class="line">    ;读取剩余的扇区</span><br><span class="line">    push ds ;以下要用到并改变DS寄存器</span><br><span class="line"></span><br><span class="line">    mov cx,ax ;循环次数（剩余扇区数）</span><br><span class="line"></span><br><span class="line">@2:</span><br><span class="line">    mov ax,ds</span><br><span class="line">    add ax,0x20 ;得到下一个以512字节为边界的段地址</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    xor bx,bx ;每次读时，偏移地址始终为0x0000</span><br><span class="line">    inc si ;下一个逻辑扇区</span><br><span class="line">    call read_hard_disk_0</span><br><span class="line">    loop @2 ;循环读，直到读完整个功能程序</span><br><span class="line">    pop ds ;恢复数据段基址到用户程序头部段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;计算入口点代码段基址</span><br><span class="line">direct:</span><br><span class="line">	mov dx,[0x08]</span><br><span class="line">    mov ax,[0x06]</span><br><span class="line">    call calc_segment_base</span><br><span class="line">    mov [0x06],ax ;回填修正后的入口点代码段基址</span><br><span class="line"></span><br><span class="line">    ;开始处理段重定位表</span><br><span class="line">    mov cx,[0x0a] ;需要重定位的项目数量</span><br><span class="line">    mov bx,0x0c ;重定位表首地址</span><br><span class="line"></span><br><span class="line">realloc:</span><br><span class="line">    mov dx,[bx+0x02] ;32位地址的高16位</span><br><span class="line">    mov ax,[bx]</span><br><span class="line">    call calc_segment_base</span><br><span class="line">    mov [bx],ax ;回填段的基址</span><br><span class="line">    add bx,4 ;下一个重定位项（每项占4个字节）</span><br><span class="line">    loop realloc</span><br><span class="line"></span><br><span class="line">    jmp far [0x04] ;转移到用户程序</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0: ;从硬盘读取一个逻辑扇区</span><br><span class="line">    ;输入：DI:SI=起始逻辑扇区号</span><br><span class="line">    ; DS:BX=目标缓冲区地址</span><br><span class="line">    push ax ;子程序，把本子程序的寄存器数据压栈，子程序结束前恢复他们</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line"></span><br><span class="line">    mov dx,0x1f2</span><br><span class="line">    mov al,1</span><br><span class="line">    out dx,al ;读取的扇区数</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f3</span><br><span class="line">    mov ax,si</span><br><span class="line">    out dx,al ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f4</span><br><span class="line">    mov al,ah</span><br><span class="line">    out dx,al ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f5</span><br><span class="line">    mov ax,di</span><br><span class="line">    out dx,al ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f6</span><br><span class="line">    mov al,0xe0 ;LBA28模式，主盘</span><br><span class="line">    or al,ah ;LBA地址27~24</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f7</span><br><span class="line">    mov al,0x20 ;读命令</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">.waits:</span><br><span class="line">    in al,dx</span><br><span class="line">    and al,0x88</span><br><span class="line">    cmp al,0x08</span><br><span class="line">    jnz .waits ;不忙，且硬盘已准备好数据传输</span><br><span class="line"></span><br><span class="line">    mov cx,256 ;总共要读取的字数</span><br><span class="line">    mov dx,0x1f0</span><br><span class="line">.readw:</span><br><span class="line">    in ax,dx</span><br><span class="line">    mov [bx],ax</span><br><span class="line">    add bx,2</span><br><span class="line">    loop .readw</span><br><span class="line"></span><br><span class="line">    pop dx</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">calc_segment_base: ;计算16位段地址</span><br><span class="line">    ;输入：DX:AX=32位物理地址</span><br><span class="line">    ;返回：AX=16位段基地址</span><br><span class="line">    push dx</span><br><span class="line"></span><br><span class="line">    add ax,[cs:phy_base]</span><br><span class="line">    adc dx,[cs:phy_base+0x02]</span><br><span class="line">    shr ax,4</span><br><span class="line">    ror dx,4</span><br><span class="line">    and dx,0xf000</span><br><span class="line">    or ax,dx</span><br><span class="line"></span><br><span class="line">    pop dx</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">phy_base dd 0x10000 ;用户程序被加载的物理起始地址</span><br><span class="line"></span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<h3 id="RTC周期中断-显示时间"><a class="header-anchor" href="#RTC周期中断-显示时间">¶</a>RTC周期中断,显示时间</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;===============================================================================</span><br><span class="line">SECTION header vstart=0 ;定义用户程序头部段</span><br><span class="line">    program_length dd program_end ;程序总长度[0x00]</span><br><span class="line">        ;用户程序入口点</span><br><span class="line">    code_entry dw start ;偏移地址[0x04]</span><br><span class="line">    dd section.code.start ;段地址[0x06]</span><br><span class="line"></span><br><span class="line">    realloc_tbl_len dw (header_end-realloc_begin)/4</span><br><span class="line">    ;段重定位表项个数[0x0a]</span><br><span class="line"></span><br><span class="line">realloc_begin:</span><br><span class="line">    ;段重定位表</span><br><span class="line">    code_segment dd section.code.start ;[0x0c]</span><br><span class="line">    data_segment dd section.data.start ;[0x14]</span><br><span class="line">    stack_segment dd section.stack.start ;[0x1c]</span><br><span class="line"></span><br><span class="line">header_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION code align=16 vstart=0 ;定义代码段（16字节对齐）</span><br><span class="line">new_int_0x70:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">.w0:</span><br><span class="line">    mov al,0x0a ;阻断NMI。当然，通常是不必要的</span><br><span class="line">    or al,0x80</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读寄存器A</span><br><span class="line">    test al,0x80 ;测试第7位UIP</span><br><span class="line">    jnz .w0 ;以上代码对于更新周期结束中断来说</span><br><span class="line">    ;是不必要的</span><br><span class="line">    xor al,al</span><br><span class="line">    or al,0x80</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读RTC当前时间(秒)</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov al,2</span><br><span class="line">    or al,0x80</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读RTC当前时间(分)</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov al,4</span><br><span class="line">    or al,0x80</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读RTC当前时间(时)</span><br><span class="line">    push ax</span><br><span class="line"></span><br><span class="line">    mov al,0x0c ;寄存器C的索引。且开放NMI</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读一下RTC的寄存器C，否则只发生一次中断</span><br><span class="line">    ;此处不考虑闹钟和周期性中断的情况</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    pop ax</span><br><span class="line">    call bcd_to_ascii</span><br><span class="line">    mov bx,12*160 + 36*2 ;从屏幕上的12行36列开始显示</span><br><span class="line"></span><br><span class="line">    mov [es:bx],ah</span><br><span class="line">    mov [es:bx+2],al ;显示两位小时数字</span><br><span class="line"></span><br><span class="line">    mov byte [es:bx+4], &#x27;:&#x27;;显示分隔符&#x27;:&#x27;</span><br><span class="line">    not byte [es:bx+5] ;反转显示属性</span><br><span class="line"></span><br><span class="line">    pop ax</span><br><span class="line">    call bcd_to_ascii</span><br><span class="line">    mov [es:bx+6],ah</span><br><span class="line">    mov [es:bx+8],al ;显示两位分钟数字</span><br><span class="line"></span><br><span class="line">    mov byte [es:bx+10], &#x27;:&#x27;;显示分隔符&#x27;:&#x27;</span><br><span class="line">    not byte [es:bx+11] ;反转显示属性</span><br><span class="line"></span><br><span class="line">    pop ax</span><br><span class="line">    call bcd_to_ascii</span><br><span class="line">    mov [es:bx+12],ah</span><br><span class="line">    mov [es:bx+14],al ;显示两位小时数字</span><br><span class="line"></span><br><span class="line">    mov al,0x20 ;中断结束命令EOI</span><br><span class="line">    out 0xa0,al ;向从片发送</span><br><span class="line">    out 0x20,al ;向主片发送</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop dx</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">bcd_to_ascii: ;BCD码转ASCII</span><br><span class="line">    ;输入：AL=bcd码</span><br><span class="line">    ;输出：AX=ascii</span><br><span class="line">    mov ah,al ;分拆成两个数字</span><br><span class="line">    and al,0x0f ;仅保留低4位</span><br><span class="line">    add al,0x30 ;转换成ASCII</span><br><span class="line"></span><br><span class="line">    shr ah,4 ;逻辑右移4位</span><br><span class="line">    and ah,0x0f</span><br><span class="line">    add ah,0x30</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">    mov ax,[stack_segment]</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,ss_pointer</span><br><span class="line">    mov ax,[data_segment]</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov bx,init_msg ;显示初始信息</span><br><span class="line">    call put_string</span><br><span class="line"></span><br><span class="line">    mov bx,inst_msg ;显示安装信息</span><br><span class="line">    call put_string</span><br><span class="line"></span><br><span class="line">    mov al,0x70</span><br><span class="line">    mov bl,4</span><br><span class="line">    mul bl ;计算0x70号中断在IVT中的偏移</span><br><span class="line">    mov bx,ax</span><br><span class="line"></span><br><span class="line">    cli ;防止改动期间发生新的0x70号中断</span><br><span class="line"></span><br><span class="line">    push es</span><br><span class="line">    mov ax,0x0000</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word [es:bx],new_int_0x70 ;偏移地址。</span><br><span class="line">    mov word [es:bx+2],cs ;段地址</span><br><span class="line">    pop es</span><br><span class="line"></span><br><span class="line">    mov al,0x0b ;RTC寄存器B</span><br><span class="line">    or al,0x80 ;阻断NMI</span><br><span class="line">    out 0x70,al</span><br><span class="line">    mov al,0x12 ;设置寄存器B，禁止周期性中断，开放更新</span><br><span class="line">    out 0x71,al ;新结束后中断，BCD码，24小时制</span><br><span class="line"></span><br><span class="line">    mov al,0x0c</span><br><span class="line">    out 0x70,al</span><br><span class="line">    in al,0x71 ;读RTC寄存器C，复位未决的中断状态</span><br><span class="line"></span><br><span class="line">    in al,0xa1 ;读8259从片的IMR寄存器</span><br><span class="line">    and al,0xfe ;清除bit 0(此位连接RTC)</span><br><span class="line">    out 0xa1,al ;写回此寄存器</span><br><span class="line"></span><br><span class="line">    sti ;重新开放中断</span><br><span class="line"></span><br><span class="line">    mov bx,done_msg ;显示安装完成信息</span><br><span class="line">    call put_string</span><br><span class="line"></span><br><span class="line">    mov bx,tips_msg ;显示提示信息</span><br><span class="line">    call put_string</span><br><span class="line"></span><br><span class="line">    mov cx,0xb800</span><br><span class="line">    mov ds,cx</span><br><span class="line">    mov byte [12*160 + 33*2],&#x27;@&#x27; ;屏幕第12行，35列</span><br><span class="line"></span><br><span class="line">.idle:</span><br><span class="line">    hlt ;使CPU进入低功耗状态，直到用中断唤醒</span><br><span class="line">    not byte [12*160 + 33*2+1] ;反转显示属性</span><br><span class="line">    jmp .idle</span><br><span class="line"></span><br><span class="line">    ;-------------------------------------------------------------------------------</span><br><span class="line">put_string: ;显示串(0结尾)。</span><br><span class="line">    ;输入：DS:BX=串地址</span><br><span class="line">    mov cl,[bx]</span><br><span class="line">    or cl,cl ;cl=0 ?</span><br><span class="line">    jz .exit ;是的，返回主程序</span><br><span class="line">    call put_char</span><br><span class="line">    inc bx ;下一个字符</span><br><span class="line">    jmp put_string</span><br><span class="line"></span><br><span class="line">    .exit:</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">put_char: ;显示一个字符</span><br><span class="line">    ;输入：cl=字符ascii</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    ;以下取当前光标位置</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    in al,dx ;高8位</span><br><span class="line">    mov ah,al</span><br><span class="line"></span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    in al,dx ;低8位</span><br><span class="line">    mov bx,ax ;BX=代表光标位置的16位数</span><br><span class="line"></span><br><span class="line">    cmp cl,0x0d ;回车符？</span><br><span class="line">    jnz .put_0a ;不是。看看是不是换行等字符</span><br><span class="line">    mov ax,bx ;</span><br><span class="line">    mov bl,80</span><br><span class="line">    div bl</span><br><span class="line">    mul bl</span><br><span class="line">    mov bx,ax</span><br><span class="line">    jmp .set_cursor</span><br><span class="line"></span><br><span class="line">.put_0a:</span><br><span class="line">    cmp cl,0x0a ;换行符？</span><br><span class="line">    jnz .put_other ;不是，那就正常显示字符</span><br><span class="line">    add bx,80</span><br><span class="line">    jmp .roll_screen</span><br><span class="line"></span><br><span class="line">    .put_other: ;正常显示字符</span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov es,ax</span><br><span class="line">    shl bx,1</span><br><span class="line">    mov [es:bx],cl</span><br><span class="line"></span><br><span class="line">    ;以下将光标位置推进一个字符</span><br><span class="line">    shr bx,1</span><br><span class="line">    add bx,1</span><br><span class="line"></span><br><span class="line">.roll_screen:</span><br><span class="line">    cmp bx,2000 ;光标超出屏幕？滚屏</span><br><span class="line">    jl .set_cursor</span><br><span class="line"></span><br><span class="line">    mov ax,0xb800</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov es,ax</span><br><span class="line">    cld</span><br><span class="line">    mov si,0xa0</span><br><span class="line">    mov di,0x00</span><br><span class="line">    mov cx,1920</span><br><span class="line">    rep movsw</span><br><span class="line">    mov bx,3840 ;清除屏幕最底一行</span><br><span class="line">    mov cx,80</span><br><span class="line">    .cls:</span><br><span class="line">    mov word[es:bx],0x0720</span><br><span class="line">    add bx,2</span><br><span class="line">    loop .cls</span><br><span class="line"></span><br><span class="line">    mov bx,1920</span><br><span class="line"></span><br><span class="line">.set_cursor:</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    mov al,bh</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    mov dx,0x3d5</span><br><span class="line">    mov al,bl</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line">    pop dx</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION data align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    init_msg db &#x27;Starting...&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">    inst_msg db &#x27;Installing a new interrupt 70H...&#x27;,0</span><br><span class="line"></span><br><span class="line">    done_msg db &#x27;Done.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">    tips_msg db &#x27;Clock is now working.&#x27;,0</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    resb 256</span><br><span class="line">ss_pointer:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION program_trail</span><br><span class="line">program_end:</span><br><span class="line"></span><br><span class="line">;bochsrc</span><br><span class="line">;设置时钟同步添加以下指令</span><br><span class="line">;clock: sync=realtime,time0=1,rtc_sync=1</span><br></pre></td></tr></table></figure>
<h3 id="BIOS功能调用"><a class="header-anchor" href="#BIOS功能调用">¶</a>BIOS功能调用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;===============================================================================</span><br><span class="line">SECTION header vstart=0 ;定义用户程序头部段</span><br><span class="line">    program_length dd program_end ;程序总长度[0x00]</span><br><span class="line">    ;用户程序入口点</span><br><span class="line">    code_entry dw start ;偏移地址[0x04]</span><br><span class="line">    dd section.code.start ;段地址[0x06]</span><br><span class="line"></span><br><span class="line">    realloc_tbl_len dw (header_end-realloc_begin)/4</span><br><span class="line">    ;段重定位表项个数[0x0a]</span><br><span class="line"></span><br><span class="line">    realloc_begin:</span><br><span class="line">    ;段重定位表</span><br><span class="line">    code_segment dd section.code.start ;[0x0c]</span><br><span class="line">    data_segment dd section.data.start ;[0x14]</span><br><span class="line">    stack_segment dd section.stack.start ;[0x1c]</span><br><span class="line"></span><br><span class="line">header_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION code align=16 vstart=0 ;定义代码段（16字节对齐）</span><br><span class="line">start:</span><br><span class="line">    mov ax,[stack_segment]</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,ss_pointer</span><br><span class="line">    mov ax,[data_segment]</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov cx,msg_end-message</span><br><span class="line">    mov bx,message</span><br><span class="line"></span><br><span class="line">.putc:</span><br><span class="line">    mov ah,0x0e</span><br><span class="line">    mov al,[bx]</span><br><span class="line">    int 0x10</span><br><span class="line">    inc bx</span><br><span class="line">    loop .putc</span><br><span class="line"></span><br><span class="line">.reps:</span><br><span class="line">    mov ah,0x00</span><br><span class="line">    int 0x16</span><br><span class="line"></span><br><span class="line">    mov ah,0x0e</span><br><span class="line">    mov bl,0x07</span><br><span class="line">    int 0x10</span><br><span class="line"></span><br><span class="line">jmp .reps</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION data align=16 vstart=0</span><br><span class="line"></span><br><span class="line">    message db &#x27;Hello, friend!&#x27;,0x0d,0x0a</span><br><span class="line">    db &#x27;This simple procedure used to demonstrate &#x27;</span><br><span class="line">    db &#x27;the BIOS interrupt.&#x27;,0x0d,0x0a</span><br><span class="line">    db &#x27;Please press the keys on the keyboard -&gt;&#x27;</span><br><span class="line">msg_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION stack align=16 vstart=0</span><br><span class="line">    resb 256</span><br><span class="line">ss_pointer:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION program_trail</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>
<h1 id="保护模式-x86阶段"><a class="header-anchor" href="#保护模式-x86阶段">¶</a>保护模式+x86阶段</h1>
<h2 id="寄存器-2"><a class="header-anchor" href="#寄存器-2">¶</a>寄存器</h2>
<h3 id="通用寄存器-2"><a class="header-anchor" href="#通用寄存器-2">¶</a>通用寄存器</h3>
<blockquote>
<p>EAX,EBX,ECX,EDX,EDI,ESI,EBP,ESP</p>
</blockquote>
<h3 id="段选择器-还是16位寄存器，但作用发生了改变"><a class="header-anchor" href="#段选择器-还是16位寄存器，但作用发生了改变">¶</a>段选择器(还是16位寄存器，但作用发生了改变)</h3>
<blockquote>
<p>SS,DS,CS,ES,<strong>FS,GS</strong>，<strong>保护模式下段寄存器用来保存描述符的选择子，不再用来保存逻辑地址。</strong></p>
<p>他们都拥有一个只有处理器能使用的<strong>描述符高速缓存器</strong>，用来存放段的线性基地址、界限和属性。段选择器的内容是段描述符的段选择子。段选择子的内容传递个段选择器后，段选择器立即根据段选择子去找到描述符表中的描述符，并取出它。然后将内容传奇个段选择器的描述符高速缓存器中，<strong>从此程序用描述符高速缓存器中的段基地址加上段内偏移地址访问数据</strong>。</p>
<p><strong>32位系统，实模式同样是使用描述符高速缓存器的，他将寄存器中的值左移4位，变为32的基地址（低20有效），高12位全为0。</strong></p>
</blockquote>
<ul>
<li>FS： 附加段寄存器(Extra Segment Register) ，其值为附加数据段的段值；</li>
<li>GS： 附加段寄存器(Extra Segment Register) ，其值为附加数据段的段值。</li>
</ul>
<h4 id="段选择子-16位"><a class="header-anchor" href="#段选择子-16位">¶</a>段选择子(16位)</h4>
<blockquote>
<p>简称选择子(Segment Select:SS)。用来在描述符表中选择一个描述符。</p>
<p>bit15~bit3:描述符索引。最大是8192(2的13次方)，索引从0开始。</p>
<p>bit2:TI(Table Indicator)表指示器。为0时，代表描述符在全局描述符表(GDT)中；为1时，代表在描述符表LDT中。</p>
<p>bit1~bit0:RPL,请求特权级。本程序的特权级。</p>
</blockquote>
<h3 id="全局描述符表寄存器GDTR"><a class="header-anchor" href="#全局描述符表寄存器GDTR">¶</a>全局描述符表寄存器GDTR</h3>
<blockquote>
<p><strong>48位寄存器</strong>。用于跟踪GDT表。保存了GDT的起始线性地址和GDT界限值。</p>
<p><strong>起始地址：通常情况下等于物理地址，但不总是等于</strong>。</p>
</blockquote>
<h3 id="控制寄存器"><a class="header-anchor" href="#控制寄存器">¶</a>控制寄存器</h3>
<ul>
<li>CR0</li>
</ul>
<blockquote>
<p>处理器内部寄存器，还有CR1，CR2等等寄存器。CR0是32位寄存器。CR0的bit0：PE，代表着实模式与保护模式的分解线。为0时是实模式，为1时时保护模式。</p>
</blockquote>
<h3 id="标志寄存器-2"><a class="header-anchor" href="#标志寄存器-2">¶</a>标志寄存器</h3>
<ul>
<li>bit21(ID):判断CPU是否支持cpuid（为1支持，为0不支持）。</li>
</ul>
<h3 id="任务寄存器TR"><a class="header-anchor" href="#任务寄存器TR">¶</a>任务寄存器TR</h3>
<blockquote>
<p>用来指向当前任务的tss.寄存器结构类似于段寄存器（段选择器，也有描述符高速缓存器。）</p>
<p>ltr执行：加载ltr选择子到tss选择器，一旦ltr选择器部分发生改变，处理器立刻用ltr选择器中的选择子到gdt中查找对应的ltr描述符，将它传送到ltr的描述符高速缓存器中。</p>
</blockquote>
<h3 id="局部描述符表寄存器LDTR"><a class="header-anchor" href="#局部描述符表寄存器LDTR">¶</a>局部描述符表寄存器LDTR</h3>
<blockquote>
<p>用来指向当前任务的ldt.寄存器结构类似于段寄存器（段选择器，也有描述符高速缓存器。）</p>
<p>lldt执行：加载ldt选择子到ldt选择器，一旦ldt选择器部分发生改变，处理器立刻用ldt选择器中的选择子到gdt中查找对应的ldt描述符，将它传送到ldt的描述符高速缓存器中。</p>
</blockquote>
<h2 id="内存布局"><a class="header-anchor" href="#内存布局">¶</a>内存布局</h2>
<h3 id="高位内存区"><a class="header-anchor" href="#高位内存区">¶</a>高位内存区</h3>
<blockquote>
<p>实模式下，32处理器地址线不止20根了，可以访问到FFFFF~10FFEF的内存了。这段内存区就叫做高位内存区（High Memory Area：HMA）</p>
</blockquote>
<h2 id="寻址方式-2"><a class="header-anchor" href="#寻址方式-2">¶</a>寻址方式</h2>
<h3 id="内存寻址-2"><a class="header-anchor" href="#内存寻址-2">¶</a>内存寻址</h3>
<ul>
<li>32位处理器特有的内存寻址方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">寄存器  +   寄存器          X    比例因子+ 内存偏移</span><br><span class="line">EAX			EAX				   1</span><br><span class="line">EBX			EBX</span><br><span class="line">ECX			ECX				   2</span><br><span class="line">EDX			EDX</span><br><span class="line">ESP		+	不能使用ESP		X	4		+ 8位或32位偏移量（没有16位）</span><br><span class="line">EBP			EBP</span><br><span class="line">ESI			ESI				   8</span><br><span class="line">EDI			EDI</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">add eax,[0x2008]</span><br><span class="line">sub eax,[eax+0x08]</span><br><span class="line">mov ecx,[eax+ebx*8+0x0s]</span><br><span class="line">mov ax,sp;非法，16位寄存器不能使用sp做寻址</span><br><span class="line">mov eax,esp</span><br></pre></td></tr></table></figure>
<h2 id="指令-2"><a class="header-anchor" href="#指令-2">¶</a>指令</h2>
<h3 id="指令集"><a class="header-anchor" href="#指令集">¶</a>指令集</h3>
<table>
    <tr>
        <th align="center">指令</th>
        <th align="center">使用</th>
    </tr>
    <tr>
        <td>lgdt</td>
        <td>内存地址指向一个48为的内存地址（16为界限值+32位段基地址），它不影响任何标志位</td>
    </tr>
    <tr>
        <td>jmp</td>
        <td>实模式：jmp 逻辑段地址：段内偏移地址<br>保护模式：jmp 描述符选择子：段内偏移地址</td>
    </tr>
    <tr>
        <td>xchg</td>
        <td>数据交换。[xchg r/m,r/m]</td>
    </tr>
    <tr>
    	<td>bits</td>
    	<td>bits 16/32:指定本条命令后面的代码的操作尺寸。使用bits时，可能会影响到处理器的流水线中的指令，会清除。实模式和保护模式<b>默认都是16位尺寸的</b>，进入保护模式后需要32位的话需要切换。<pre>
    	bits 16 ;或[bits 16] 
    	mov ds,ax
		bits 32 ;或[bits 32]
		mov ds,ax;
		此时编译器会给机器码多一个指令前缀66，会影响工作效率;正确的做法是：mov ds,eax。但nasm编译器无论16位还是32位都不会出现前缀66</pre></td>
    </tr>
    <tr>
        <td>bswap</td>
        <td>操作数只能时寄存器[bswap r].它用来反转操作数的字节序。若是32位的操作数：</br>原来的0~7变为了24~31.</br>原来的8~15变为了16~23.</br>原来的16~23变为了8~15.</br>原来的24~31变为了0~7.</td>
    </tr>
	<tr>
        <td>cpuid</td>
        <td>CPU Indentification.获取CPU品牌信息。使用前使用eax(功能号)指定要返回的信息。</td>
	</tr>
	<tr>
        <td>指令族vmov..</td>
        <td><pre>cmov.. r,r/m(r只能是16位，32位，或者64位的，不能是8位)
        cmovnz al,bl;非法
        cmovg ax,[0x2008]
        cmovge [0x2008],ecx
        cmp eax,edx
        cmovne eax,edx;如果不相等则，把edx值赋给eax</pre></td>
    </tr>
	<tr>
        <td>sgdt</td>
        <td>[sgdt m].获取gdt的信息保存到指定地址中，这个地址必须要有6个字节大小。</td>
	</tr>
	<tr>
        <td>movzx</td>
        <td>带0扩展指令。扩充小的数到大的数中。（左边补零）<pre>movzx r16,r8/m8
        movzx r32,r8/m8
        movzx r64,r8/m8
        movzx r32,r16/m16
        movzx r64,r16/m16</pre></td>
	</tr>
	<tr>
        <td>串数据比较</td>
        <td>[cmpsb,cmpsw,cmpsd,cmpsq],他有两个比较串，都必须位于内存中，都有自己的长度。比较时是采用默认尺寸决定使用什么寄存器的。详细见【串比较】</td>
	</tr>
	<tr>
        <td>pushad/popad</td>
        <td>压入/弹出所有的双字的寄存器到栈中。</br>压栈顺序：eax-ecx-edx-ebx-esp-ebp-esi-edi</br>出栈顺序：edi-esi-ebp-废弃-ebx-edx-ecx-eax</td>
	</tr>
	<tr>
        <td>xlat</td>
        <td>指令执行时，处理器访问指定的表格，用AL中的数字作为偏移量，从表中取出一个字节，传回AL寄存器。隐含操作数：段寄存器DS指向转换表所在段的选择子【类似于数组】。默认尺寸是16位时，使用BX指定转换表的段内偏移。默认尺寸是32位时，使用EBX指定转换表的段内偏移。AL=数字。执行执行后，AL=从表中取出的字节数据。</td>
	</tr>
	<tr>
        <td>push</td>
        <td>32位处理器支持push直接压入立即数。压入寄存器的实际数据大小需要根据实际判断。</td>
	</tr>
	<tr>
        <td>ltr/lldt</td>
        <td>ltr:加载tss到TR寄存器。</br>lldt：加载ldt到LDTR寄存器。</br>他们操作数或者操作基址都是选择子或者存储着选择子。（tss选择子，ldt选择子）</td>
	</tr>
</table>
<h3 id="串比较"><a class="header-anchor" href="#串比较">¶</a>串比较</h3>
<table>
<thead>
<tr>
<th>默认操作尺寸</th>
<th>目的串</th>
<th>源串</th>
<th>REP前缀使用的计数器</th>
</tr>
</thead>
<tbody>
<tr>
<td>16</td>
<td>ES:DI</td>
<td>DS:SI</td>
<td>CX</td>
</tr>
<tr>
<td>32</td>
<td>ES:EDI</td>
<td>DS:ESI</td>
<td>ECX</td>
</tr>
<tr>
<td>64</td>
<td>ES:RDI</td>
<td>DS:RSI</td>
<td>RCX</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>重复前缀</th>
<th>终止条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>rep</td>
<td>CX/ECX/RCX=0</td>
</tr>
<tr>
<td>repe/repz</td>
<td>CX/ECX/RCX=0并且ZF=0</td>
</tr>
<tr>
<td>repne/repnz</td>
<td>CX/ECX/RCX=0并且ZF=1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>他们只会从指定内存中拿出对应大小数据去比较<strong>一次</strong>。所以需要搭配rep执行使用。而我们又需要知道比较多少次，所以rep使用时需要一个前缀计数器。也因为如此，我们需要在比较前设定好指定的计数器大小（串总大小除于每次比较的大小）。因为串比较指令会影响标志寄存器，所以循环可使用其他衍生指令。比较方向由标志寄存器DF位决定（DF＝０，从开头开始，DI和SI递增；DF＝１，从结尾开始，DI和SI递减）。</p>
</blockquote>
<ul>
<li>具体使用细节
<ul>
<li>1.用CLD或者STD清除或设置方向位标志DF；</li>
<li>2.根据处理器的默认操作尺寸和方向标志，设置DS和SI/ESI/RSI指向源串；</li>
<li>3.根据处理器的默认操作尺寸和方向标志，设置ES和DI/EDI/RDI指向源串；</li>
<li>4.根据处理器的默认操作尺寸及选择串的比较指令，将比较次数传送到CX/ECX/RCX;</li>
<li>5.根据实际情况，选择以串比较指令冲的一个；</li>
<li>6.根据实际情况，为串比较指令指定一个前缀，可以是repz/repe/repnz/repne;</li>
<li>7.重复比较结束后，根据零标志ZF最后的状态是0还是1，判断两个串是否相同。</li>
</ul>
</li>
</ul>
<h3 id="操作尺寸"><a class="header-anchor" href="#操作尺寸">¶</a>操作尺寸</h3>
<blockquote>
<p>指令的操作长度是指指令中操作数的长度及有效地址（偏移地址、偏移量）的长度。为了设计和扩展指令系统，32为处理器将操作尺寸定义为两种：16位操作尺寸和32位操作尺寸。</p>
<p>16位操作尺寸允许8位或者16位操作数，以及16位有效地址。</p>
<p>32位操作尺寸允许8位或者32位操作数(<strong>没有16位</strong>)，以及32位有效地址。</p>
</blockquote>
<h4 id="默认操作尺寸"><a class="header-anchor" href="#默认操作尺寸">¶</a>默认操作尺寸</h4>
<blockquote>
<p>32位处理器虽然有两种尺寸，但是，在同一时刻，处理器只能按一种操作尺寸工作，要么选择16位操作尺寸，要么选择32位操作尺寸，着叫做处理器的默认操作尺寸。<strong>可从描述符中的属性D/B知道是多少位的。<strong>当指令有66/67前缀时，指令执行</strong>会多一个时钟周期</strong>，所以应该尽量减少前缀的添加。</p>
</blockquote>
<ul>
<li>当默认操作尺寸为16位时的指令前缀</li>
</ul>
<blockquote>
<p>66:<strong>反转</strong>操作数为32位；67：<strong>反转</strong>有效地址为32位。</p>
</blockquote>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>机器指令</th>
<th>操作尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ad,dl</td>
<td>0x<strong>88D0</strong></td>
<td>8位数据</td>
</tr>
<tr>
<td>mov ax,dx</td>
<td>0x89D0</td>
<td>16位数据</td>
</tr>
<tr>
<td>mov eax,edx</td>
<td>0x<strong>66</strong>89D0</td>
<td>32位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mov [bx+di],dh</td>
<td>0x<strong>8831</strong></td>
<td>8位数据，16位数据</td>
</tr>
<tr>
<td>mov [bx+di],si</td>
<td>0x8931</td>
<td>16位数据，16位数据</td>
</tr>
<tr>
<td>mov [bx+di],esi</td>
<td>0x<strong>66</strong>8931</td>
<td>32位数据，16位数据</td>
</tr>
<tr>
<td>mov [ecx],esi</td>
<td>0x<strong>6667</strong>8931</td>
<td>32位数据，32位数据</td>
</tr>
<tr>
<td>mov [ecx],si</td>
<td>0x<strong>67</strong>8931</td>
<td>16位数据，32位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>movsb</td>
<td>0xA4</td>
<td>8位数据</td>
</tr>
<tr>
<td>movsw</td>
<td>0xA5</td>
<td>16位数据</td>
</tr>
<tr>
<td>movsd</td>
<td>0x<strong>66</strong>A6</td>
<td>32位数据</td>
</tr>
</tbody>
</table>
<ul>
<li>当默认操作尺寸为32位时的指令前缀</li>
</ul>
<blockquote>
<p>66:<strong>反转</strong>操作数为16位；67：<strong>反转</strong>有效地址为16位。</p>
</blockquote>
<table>
<thead>
<tr>
<th>汇编指令</th>
<th>机器指令</th>
<th>操作尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td>mov ad,dl</td>
<td>0x<strong>88D0</strong></td>
<td>8位数据</td>
</tr>
<tr>
<td>mov ax,dx</td>
<td>0x<strong>66</strong>89D0</td>
<td>16位数据</td>
</tr>
<tr>
<td>mov eax,edx</td>
<td>0x89D0</td>
<td>32位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mov [bx+di],dh</td>
<td>0x<strong>8831</strong></td>
<td>8位数据，16位数据</td>
</tr>
<tr>
<td>mov [bx+di],si</td>
<td>0x<strong>6667</strong>8931</td>
<td>16位数据，16位数据</td>
</tr>
<tr>
<td>mov [bx+di],esi</td>
<td>0x<strong>67</strong>8931</td>
<td>32位数据，16位数据</td>
</tr>
<tr>
<td>mov [ecx],esi</td>
<td>0x8931</td>
<td>32位数据，32位数据</td>
</tr>
<tr>
<td>mov [ecx],si</td>
<td>0x<strong>66</strong>8931</td>
<td>16位数据，32位数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>movsb</td>
<td>0xA4</td>
<td>8位数据</td>
</tr>
<tr>
<td>movsw</td>
<td>0x<strong>66</strong>A5</td>
<td>16位数据</td>
</tr>
<tr>
<td>movsd</td>
<td>0xA6</td>
<td>32位数据</td>
</tr>
</tbody>
</table>
<h3 id="push压入立即数"><a class="header-anchor" href="#push压入立即数">¶</a>push压入立即数</h3>
<blockquote>
<p>实际数据压栈尺寸决定着出栈的接受尺寸。</p>
</blockquote>
<table>
    <tr>
        <th align="center">立即数大小</th>
        <th align="center">操作尺寸大小</th>
        <th align="center">实际压入的数据尺寸</th>
        <th align="center">栈指针的变化</th>
    </tr>
    <tr>
        <td rowspan="2">8</td>
        <td>16</td>
        <td>16:高8位的内容是操作数的符号扩展</td>
        <td>SP/ESP减2：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td>32</td>
        <td>32:高24位的内容是操作数的符号扩展</td>
        <td>SP/ESP减4：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td rowspan="2">16</td>
        <td>16</td>
        <td>16</td>
        <td>SP/ESP减2：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td>32</td>
        <td>16</td>
        <td>SP/ESP减2：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td rowspan="2">32</td>
        <td>16</td>
        <td>32</td>
        <td>SP/ESP减4：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td>32</td>
        <td>32</td>
        <td>SP/ESP减4：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
</table>
<h3 id="push压入寄存器"><a class="header-anchor" href="#push压入寄存器">¶</a>push压入寄存器</h3>
<table>
    <tr>
        <th colspan="3" align="center">push cs/push ss/push ds/push es/push fs/push gs</th>
    </tr>
    <tr>
        <th align="center">操作尺寸大小</th>
        <th align="center">实际压入的数据尺寸</th>
        <th align="center">栈指针的变化</th>
    </tr>
    <tr>
        <td>16</td>
        <td>16</td>
        <td>SP/ESP减2：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
    <tr>
        <td>32</td>
        <td>32:用比特0扩展到高16位</td>
        <td>SP/ESP减4：由栈段描述符中的B位决定是SP还是ESP</td>
    </tr>
</table>
### 带参数的ret/retf
<table>
    <tr>
        <th>指令</th>
        <th>执行的操作</th>
        <th>说明</th>
    </tr>
    <tr>
        <td>ret imm</td>
        <td>从栈中弹出数据到<b>指令指针寄存器</b></br>栈指针寄存器=栈指针寄存器+imm</td>
<td rowspan="2">指令执行时，如果处理器的默认操作尺寸是16位的，指令指针寄存器是IP，如果默认尺寸是32位的，指令指针寄存器是EIP；否则是RIP</br>栈指针寄存器是SP还是ESP，取决于SS描述符高数缓存器的B位。</td>
    </tr>
    <tr>
        <td>retf imm</td>
        <td>从栈中弹出数据到<b>指令指针寄存器</b></br>从栈中弹出数据到段寄存器CS;</br>栈指针寄存器=栈指针寄存器+imm</td>
    </tr>
</table>
<h2 id="指令格式"><a class="header-anchor" href="#指令格式">¶</a>指令格式</h2>
<blockquote>
<p>ModR/M和SIB查表：见intel相关开发手册</p>
</blockquote>
<table>
<thead>
<tr>
<th>指令前缀</th>
<th>操作码</th>
<th>ModR/M</th>
<th>SIB</th>
<th>偏移量</th>
<th>立即数</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果存在为1个字节</td>
<td>1到3个字节</td>
<td>如果存在为1个字节</td>
<td>如果存在为1个字节</td>
<td>如果存在：1/2/4个字节</td>
<td>如果存在：1/2/4个字节</td>
</tr>
</tbody>
</table>
<table>
    <tr>
        <th rowspan="2">机器码</th>
        <th rowspan="2">汇编语言指令</th>
        <th rowspan="2">操作码</th>
        <th colspan="3">ModR/M</th>
        <th colspan="3">SIB</th>
        <th rowspan="2">偏移量</th>
        <th rowspan="2">立即数</th>
    </tr>
    <tr>
        <td>mod</td>
        <td>reg</td>
        <td>r/m</td>
        <td>ss</td>
        <td>index</td>
        <td>Base</td>
    </tr>
    <tr>
        <td rowspan="2">0x031458</td>
        <td rowspan="2">add edx,[eax+ebx*2]</td>
        <td rowspan="2">0x03</td>
        <td>00b</td>
        <td>010b</td>
        <td>100b</td>
        <td>00b</td>
        <td>011b</td>
        <td>000b</td>
        <td rowspan="2"></td>
        <td rowspan="2"></td>
    </tr>
    <tr>
        <td colspan="3">0x14</td>
        <td colspan="3">0x58</td>
    </tr>
    <tr>
        <td rowspan="2">0x8184D8003C0000AA55</td>
        <td rowspan="2">add word [eax+ebx*8+0x3c00],0x55AA</td>
        <td rowspan="2">0x81</td>
        <td>10b</td>
        <td>000b</td>
        <td>100b</td>
        <td>11b</td>
        <td>011b</td>
        <td>000b</td>
        <td rowspan="2">0x003C0000</td>
        <td rowspan="2">0xAA55</td>
    </tr>
    <tr>
        <td colspan="3">0x84</td>
        <td colspan="3">0xD8</td>
    </tr>
</table>
<table>
<thead>
<tr>
<th>机器码</th>
<th>汇编指令</th>
<th>指令前缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>0xA5</td>
<td>movsw</td>
<td></td>
</tr>
<tr>
<td>0xF3A5</td>
<td>req movsw</td>
<td>req</td>
</tr>
</tbody>
</table>
<h2 id="设备交互-2"><a class="header-anchor" href="#设备交互-2">¶</a>设备交互</h2>
<h3 id="端口0x92"><a class="header-anchor" href="#端口0x92">¶</a>端口0x92</h3>
<blockquote>
<p>在32位系统中处理器有一个名为<code>A20M</code>（address 20 mask）的引脚,它连接着一个或门，或门连接着ICH(输入输出控制中心芯片，南桥芯片)的<strong>0x92端口的bit1</strong>和老式键盘的<code>0x60</code>端口(用来控制A20线的有效与否);</p>
<p>0x91-bit0:连接处理器的INIT引脚。复位处理器，从0变为1时，处理器将复位，计算机重启。</p>
</blockquote>
<h3 id="CPUID"><a class="header-anchor" href="#CPUID">¶</a>CPUID</h3>
<table>
<thead>
<tr>
<th>功能号</th>
<th>返回</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>返回CPU所支持的最大功能号。<br />返回信息：<br />eax=最大支持的功能号<br />ebx=0x756E6547,是“Genu&quot;的字符编码<br />ecx=0x49656E69,是”ineI“的字符编码<br />edx=0x6C65746E,是&quot;ntel&quot;的字符编码<br />以上三个寄存器的合成是”GenuineIntel&quot;，是供应商的信息。</td>
</tr>
<tr>
<td>1</td>
<td>返回cpu是否支持cmovcc指令族(edx的bit15:为0不支持，为1支持)。</td>
</tr>
</tbody>
</table>
<h2 id="段描述符"><a class="header-anchor" href="#段描述符">¶</a>段描述符</h2>
<h3 id="段描述符和描述符表"><a class="header-anchor" href="#段描述符和描述符表">¶</a>段描述符和描述符表</h3>
<blockquote>
<p>每个段有关的信息需要8个字节（64位）来描述，我们称之为段描述符。当段描述符集中存放时，集中存放的地方就是描述符表,主要的表就是GDT表。描述符索引从0开始，<strong>索引号乘于8就能拿到在描述符表中的偏移地址，偏移地址加上描述符表的基地址，就能拿到线性地址</strong>。</p>
<p>数据段寄存器只能加载数据段描述符，代码段寄存器只能加载代码段描述符，在加载描述符时会判断类型。<strong>但是，平时取指令或读写数据时，段的类型不做检查。</strong></p>
</blockquote>
<h3 id="全局描述符表"><a class="header-anchor" href="#全局描述符表">¶</a>全局描述符表</h3>
<blockquote>
<p>Global Descriptor Table:GDT。它必须在进入保护模式之前定义，也就是定义于实模式下。</p>
<p>处理器规定：GDT的第一个描述符必须为空描述符（或亚描述符）。</p>
</blockquote>
<h3 id="描述符属性"><a class="header-anchor" href="#描述符属性">¶</a>描述符属性</h3>
<ul>
<li>
<p>描述符分类</p>
<ul>
<li>
<p>存储器的段描述符：代码段，数据段</p>
</li>
<li>
<p>系统描述符</p>
<ul>
<li>
<p>系统的段描述符：GDT，LDT，TSS。</p>
</li>
<li>
<p>门描述符</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="描述符的属性"><a class="header-anchor" href="#描述符的属性">¶</a>描述符的属性</h4>
<blockquote>
<p>描述符中的<code>bit44位</code>，也称S位(位于高双字中)。s=0:系统描述符，且TYPE字段用来指定系统段的类型或门的类型。s=1:存储器的段描述符，且TYPE字段用来区分代码段和数据段。</p>
<p>系统拿到描述符后根据S位去确定处<code>bit44~bit40（bit43~bit40:TYPE）</code>之外的内存是什么数据。因为<strong>存储器的段描述符和系统的段描述符结构是不同的</strong>。</p>
</blockquote>
<ul>
<li>存储器段描述符格式(拆为高低双字节展示)</li>
</ul>
<table border="1">
        <tr>
            <th align="center">字节</th>
            <th align="center">比特位</th>
            <th colspan="6">属性</th>
        </tr>
        <tr>
            <td rowspan="12">高双字</td>
            <td>bit31~bit24:段基地址</td>
            <td colspan="6">段基地址的31~24位</td>
        </tr>
        <tr>
            <td>bit23:G</td>
            <td colspan="6">段界限粒度(Granularity)位。<br/>G=0:表示界限粒度为字节；<br/>G=1:表示界限粒度为4K字节。<br/>注意：界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。<br/>G=0, 实际使用的段界限=描述符中的界限值<br>G=1,实际使用的段界限=描述符中的界限值x0x1000+0xFFF</td>
        </tr>
        <tr>
            <td>bit22:D/B</td>
            <td colspan="5">对于代码段来说，它是D位。操作尺寸/栈上部边界。<br/>值为0时，段使用按16操作；值为1时，段使用32操作。也就决定段界限的大小(向下模式下，段大小是FFFF还是FFFFFFFF)</td>
            <td>对于数据段来说，它是B位。如果B=0，并且这个段是栈段时，使用的是sp寄存器。如果B=1，并且这个段是栈段时，使用的是esp寄存器。</td>
        </tr>
        <tr>
            <td>bit21:L</td>
            <td colspan="6">长(Long)模式。64位代码段标志。32位系统下为0。</td>
        </tr>
        <tr>
            <td>bit20:AVL</td>
            <td colspan="6">软件可利用(Available)位。通常由操作系统使用，处理器不使用。</td>
        </tr>
        <tr>
            <td>bit19~bit16:段界限</td>
            <td colspan="6">段界限的bit16~bit19位</td>
        </tr>
        <tr>
            <td>bit15:P</td>
            <td colspan="6">存在(Present)位。<br/>P=1 表示描述符对地址转换是有效的，或者说该描述符所描述的段存在，即在内存中；<br/>P=0 表示描述符对地址转换无效，即该段不存在。使用该描述符进行内存访问时会引起异常。</td>
        </tr>
        <tr>
            <td>bit14~bit13:DPL</td>
            <td colspan="6">表示描述符特权级(Descriptor Privilege level)，共2位。它规定了所描述段的特权级，用于特权检查，以决定对该段能否访问。 </td>
        </tr>
        <tr>
            <td>bit12:S</td>
            <td colspan="6">s=0:系统描述符，且TYPE字段用来指定系统段的类型或门的类型。<br/>s=1:存储器的段描述符，且TYPE字段用来区分代码段和数据段</td>
        </tr>
        <tr>
            <td rowspan="2" colspan="3">bit11~bit8:TYPE</td>
            <td rowspan="2">bit11:X=0(executable)时,该描述符段不可执行，通常为数据段。<br/>bit11:X=1时,该描述符段可执行，通常为代码段。</td>
            <td>X=0时;bit10为E(expand),E=0时，段向上扩展(低地址->高地址：普通段)；E=1时，段向下扩展(高地址->低地址：通常为栈段)</td>
            <td>X=0时;bit9为W,W=0,段不可写入，W=1，段可以正常写入。</td>
            <td rowspan="2">bit8:A(Accessed)：该段近期访问过或者使用过。段初始化时值为0，被访问过后置1，清0由用户软件和操作系统执行。因此通过检测A就可以知道该段的使用频率。</td>
        </tr>
        <tr>
            <td>X=1时;bit10为C，C=0时，为非亦从代码段，表示特权级相同的程序才能转移到这个段执行；C=1时，为亦从代码段，特权级低的程序可以直接转移到这个段来执行。</td>
            <td>X=1时;bit9为R,R=0,代码段不可读出，R=1，代码段可读出。</td>
        </tr>
        <tr>
            <td>bit7~bit0:段基地址</td>
            <td  colspan="6">段基地址的23~15位</td>
        </tr>
        <tr>
            <td rowspan="2">低双字</td>
            <td>bit31~bit16:段基地址</td>
            <td  colspan="6">段基地址的15~0位</td>
        </tr>
        <tr>
            <td>bit15~bit0:段界限</td>
            <td  colspan="6">段界限的bit0~bit15位。向上扩展的段，段界限值位0时，段的大小位1(0是最小偏移量)；向下扩展的段，段界限值位0时，段的大小位sp或esp的能表示的最大值(FFFF或FFFFFFFF)。</td>
        </tr>
    </table>
### 描述符类型检查
<h4 id="存储器的描述符"><a class="header-anchor" href="#存储器的描述符">¶</a>存储器的描述符</h4>
<ul>
<li>第一步：通过选择子，用<strong>索引号*8+7&lt;=边界</strong>，检查是否存在于gdt中，如果不存在，处理器中止处理，产生异常中断<strong>13</strong>。</li>
<li>第二部：检查描述符类型是否有效，检查描述符与要赋值的段寄存器是否匹配。</li>
</ul>
<table>
    <tr>
        <th rowspan="2">段寄存器</th>
        <th colspan="2">数据段(X=0)</th>
        <th colspan="2">代码段(X=1)</th>
    </tr>
    <tr>
        <td>只读(W=0)</td>
        <td>读写(W=1)</td>
        <td>只执行(R=0)</td>
        <td>执行、读(R=1)</td>
    </tr>
    <tr>
        <td>CS</td>
        <td>N</td>
        <td>N</td>
        <td>Y</td>
        <td>Y</td>
    </tr>
    <tr>
        <td>DS</td>
        <td>Y</td>
        <td>Y</td>
        <td>N</td>
        <td>Y</td>
    </tr>
    <tr>
        <td>ES</td>
        <td>Y</td>
        <td>Y</td>
        <td>N</td>
        <td>Y</td>
    </tr>
    <tr>
        <td>FS</td>
        <td>Y</td>
        <td>Y</td>
        <td>N</td>
        <td>Y</td>
    </tr>
    <tr>
        <td>GS</td>
        <td>Y</td>
        <td>Y</td>
        <td>N</td>
        <td>Y</td>
    </tr>
    <tr>
        <td>SS</td>
        <td>N</td>
        <td>Y</td>
        <td>N</td>
        <td>N</td>
    </tr>
</table>
<ul>
<li>第三步：检查属性P位，查看描述符所对应的段是否在物理内存中，如果P=0,则不存在物理内存中，它将发出中断<strong>11</strong>，把对应段调入内存中，把P置1。<strong>注意：这里中断后将返回到引起中断的指令，这样将可重新加载描述符。</strong></li>
</ul>
<blockquote>
<p>对于DS，ES，FS和GS的选择器，可以向其加载数值为0的选择子。对于cs和ss的选择器来说，不允许向其传送为0的选择子。</p>
<p>尽管在加载时不会有任何问题，但是访问内存时，会抛出异常。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,0</span><br><span class="line">mov ds,eax</span><br><span class="line">mov es,eax</span><br><span class="line">mov fs,eax</span><br><span class="line">mov gs,eax</span><br><span class="line"></span><br><span class="line">mov [ebx],ax;抛出异常</span><br></pre></td></tr></table></figure>
<h3 id="代码段执行的保护"><a class="header-anchor" href="#代码段执行的保护">¶</a>代码段执行的保护</h3>
<blockquote>
<p>G=0, 实际使用的段界限=描述符中的界限值</p>
<p>G=1,实际使用的段界限=描述符中的界限值x0x1000+0xFFF</p>
</blockquote>
<ul>
<li>但jmp 跳转到一个代码段时，cs，ip的值会被刷新。处理器执行下条指令时，将检查<strong>0&lt;=EIP+指令长度-1&lt;=实际使用的段界限</strong>,否则发出异常。</li>
<li>**段与段之间是可以重叠的。但一个数据段为00000000~FFFFFFFF时，代码段在0x7c00~0x7c00+512KB时，很明显，两个段重叠了，虽然代码段的描述符不能写入，但是可以通过重叠段的数据段去修改代码段中的值。**如果某个段的内存已经存在，又位这段内存添加一个新的段，那么这个新段就可以是旧段的别名。(实际使用将示例代码：冒泡排序)</li>
</ul>
<h3 id="向上扩展的栈段的保护"><a class="header-anchor" href="#向上扩展的栈段的保护">¶</a>向上扩展的栈段的保护</h3>
<blockquote>
<p><strong>向上的数据段也是可以作为栈段的</strong>，扩展方向并不影响段界限检查，栈的栈底栈顶方向和向下扩展的段时相同的。偏移量的变化范围也是sp/esp(使用esp还是sp,由描述符的B位来决定)的变化范围。（隐式操作push、pop、call、ret、iret都会用到esp）</p>
<p>向上扩展的栈段检查：操作数的有效地址+操作数的大小-1&lt;=实际使用的段界限</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;段基地址0x6c00,段界限0x7ff,粒度为1，向上扩展，数据段</span><br><span class="line">mov eax,0018	;选择子</span><br><span class="line">mov ss,eax		;ss设置到这个段</span><br><span class="line">mov esp,0x800	;向上扩展的栈段，应该将栈指针设置为段的大小(段大小：界限值+1)</span><br><span class="line">				;向下扩展的栈段，则是mov esp,0</span><br><span class="line"></span><br><span class="line">push dword 0x072e074d	;32位系统支持直接压入立即数到栈</span><br><span class="line">push dword 0x072e0750</span><br><span class="line"></span><br><span class="line">pop dword [0xb8000]</span><br><span class="line">pop dword [0xb8004]</span><br></pre></td></tr></table></figure>
<h2 id="GDT"><a class="header-anchor" href="#GDT">¶</a>GDT</h2>
<blockquote>
<p>为了让程序在内存中能自由的浮动而又不影响它的正常执行，处理器将内存划分成逻辑上的段，并在指令中使用段内偏移地址。在保护模式下，对内存的访问仍然使用段地址和偏移地址，但是，在每个段能够访问之前，必须先进行登记。用来存放这些信息的数据结构叫做描述符表。</p>
<p>等级信息有每个段的起始地址，段的界限等各种访问属性。这样，当你访问的偏移地址超出了段的界限时，处理器就会阻止这种访问，并产生一个叫做<strong>内部异常的中断</strong>。</p>
<p>GDT理论上可以位于内存中的任意位置，但是因为它需要在进入保护模式前定义，所以它通常位于00000~FFFFF之间。可在进入保护模式后重定位位置。gdt也有一个自己的描述符，他位于处理器当中。</p>
</blockquote>
<ul>
<li>gdt的格式：（64K大小）</li>
</ul>
<blockquote>
<p>一个一个读描述符，包括不仅限于存储器段描述符，ldt描述符，tss描述符。</p>
</blockquote>
<ul>
<li>GDTR</li>
</ul>
<blockquote>
<p><code>bit47~bit16</code>:全局描述符表段基地址；<code>bit15~bit0</code>:全局描述符边界（表大小减一）。</p>
<p>因为边界值是16位的，所以表最大65536字节，又因一个描述符占8个字节，所以最大在表中定义8192个描述符（段）。</p>
</blockquote>
<h2 id="LDT"><a class="header-anchor" href="#LDT">¶</a>LDT</h2>
<blockquote>
<p>段描述符表。分为三类：全局描述符表GDT，局部描述符表LDT和中断描述符表IDT。GDT和IDT在整个系统中只有一张，而每个任务都有自己私有的一张局部描述符表LDT，用于记录本任务中涉及的各个代码段、数据段和堆栈段以及本任务的使用的门描述符。GDT包含系统使用的代码段、数据段、堆栈段和特殊数据段描述符，以及所有任务局部描述符表LDT的描述符。</p>
<p>ldt也是一块内存区，最大也是64K，最多8192个描述符。ldt也有自己的一个描述符,每个描述符对应一个ldt，它安装在GDT表中。</p>
<p>当段描述符S位为0时，Type类型是2时（0010），这个描述符就是ldt描述符。此时D(bit22)位和L(bit21)位都为0.</p>
</blockquote>
<ul>
<li>ldt:的格式：（64K大小）</li>
</ul>
<blockquote>
<p>包括不仅限于用户程序头不断的描述符，用户程序代码段的描述符，用户程序数据段的描述符，用户程序栈段的描述符等等的存储器段描述符。</p>
</blockquote>
<h2 id="TSS"><a class="header-anchor" href="#TSS">¶</a>TSS</h2>
<blockquote>
<p>任务状态段。在一个多任务环境中，当发生了任务切换，需保护现场，因此每个任务的应当用一个额外的内存区域保存相关信息，即任务状态段(TSS)；TSS格式固定，104个字节，处理器固件能识别TSS中元素，并在任务切换时读取其中信息。tss也有自己的一个描述符，每个描述符对应一个tss,它安装在GDT表中。</p>
<p>当段描述符S位为0时，Type类型是10B1：B位为0时代表不忙，为1时代表忙，这一位由处理器固件管理（可以有效防止任务切换重加载，或者切换到自己），这个描述符就是ldt描述符。此时D(bit22)位和L(bit21)位都为0.</p>
</blockquote>
<ul>
<li>
<p>tss的格式：（104字节大小）</p>
<p><img src="/img/Assembly/tss.jpeg" alt="图片"></p>
</li>
</ul>
<h2 id="示例代码-2"><a class="header-anchor" href="#示例代码-2">¶</a>示例代码</h2>
<h3 id="GDT使用示例"><a class="header-anchor" href="#GDT使用示例">¶</a>GDT使用示例</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ;设置堆栈段和栈指针</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">    ;计算GDT所在的逻辑段地址</span><br><span class="line">    mov ax,[cs:gdt_base+0x7c00] ;低16位</span><br><span class="line">    mov dx,[cs:gdt_base+0x7c00+0x02] ;高16位</span><br><span class="line">    mov bx,16</span><br><span class="line">    div bx</span><br><span class="line">    mov ds,ax ;令DS指向该段以进行操作</span><br><span class="line">    mov bx,dx ;段内起始偏移地址</span><br><span class="line"></span><br><span class="line">    ;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">    mov dword [bx+0x00],0x00</span><br><span class="line">    mov dword [bx+0x04],0x00</span><br><span class="line"></span><br><span class="line">    ;创建#1描述符，保护模式下的代码段描述符</span><br><span class="line">    mov dword [bx+0x08],0x7c0001ff</span><br><span class="line">    mov dword [bx+0x0c],0x00409800</span><br><span class="line"></span><br><span class="line">    ;创建#2描述符，保护模式下的数据段描述符（文本模式下的显示缓冲区）</span><br><span class="line">    mov dword [bx+0x10],0x8000ffff	;描述符低双字</span><br><span class="line">    mov dword [bx+0x14],0x0040920b	;描述符高双字，他们代表着数据段，向上扩展，可写</span><br><span class="line">    								;基地址=FFFF，G=0，P=1，特权级0</span><br><span class="line"></span><br><span class="line">    ;创建#3描述符，保护模式下的堆栈段描述符</span><br><span class="line">    mov dword [bx+0x18],0x00007a00</span><br><span class="line">    mov dword [bx+0x1c],0x00409600</span><br><span class="line"></span><br><span class="line">    ;初始化描述符表寄存器GDTR</span><br><span class="line">    mov word [cs: gdt_size+0x7c00],31 ;描述符表的界限（总字节数减一）</span><br><span class="line"></span><br><span class="line">    lgdt [cs: gdt_size+0x7c00]</span><br><span class="line"></span><br><span class="line">    in al,0x92 ;南桥芯片内的端口</span><br><span class="line">    or al,0000_0010B</span><br><span class="line">    out 0x92,al ;打开A20</span><br><span class="line"></span><br><span class="line">    cli ;保护模式下中断机制尚未建立，应</span><br><span class="line">    ;禁止中断</span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or eax,1</span><br><span class="line">    mov cr0,eax ;设置PE位</span><br><span class="line"></span><br><span class="line">    ;以下进入保护模式... ...</span><br><span class="line">    jmp dword 0x0008:flush ;16位的描述符选择子：32位偏移</span><br><span class="line">    ;清流水线并串行化处理器</span><br><span class="line">    [bits 32]</span><br><span class="line"></span><br><span class="line">flush:</span><br><span class="line">    mov cx,00000000000_10_000B ;加载数据段选择子(0x10)，索引从0开始</span><br><span class="line">    mov ds,cx</span><br><span class="line"></span><br><span class="line">    ;以下在屏幕上显示&quot;Protect mode OK.&quot;</span><br><span class="line">    mov byte [0x00],&#x27;P&#x27;</span><br><span class="line">    mov byte [0x02],&#x27;r&#x27;</span><br><span class="line">    mov byte [0x04],&#x27;o&#x27;</span><br><span class="line">    mov byte [0x06],&#x27;t&#x27;</span><br><span class="line">    mov byte [0x08],&#x27;e&#x27;</span><br><span class="line">    mov byte [0x0a],&#x27;c&#x27;</span><br><span class="line">    mov byte [0x0c],&#x27;t&#x27;</span><br><span class="line">    mov byte [0x0e],&#x27; &#x27;</span><br><span class="line">    mov byte [0x10],&#x27;m&#x27;</span><br><span class="line">    mov byte [0x12],&#x27;o&#x27;</span><br><span class="line">    mov byte [0x14],&#x27;d&#x27;</span><br><span class="line">    mov byte [0x16],&#x27;e&#x27;</span><br><span class="line">    mov byte [0x18],&#x27; &#x27;</span><br><span class="line">    mov byte [0x1a],&#x27;O&#x27;</span><br><span class="line">    mov byte [0x1c],&#x27;K&#x27;</span><br><span class="line"></span><br><span class="line">    ;以下用简单的示例来帮助阐述32位保护模式下的堆栈操作</span><br><span class="line">    mov cx,00000000000_11_000B ;加载堆栈段选择子</span><br><span class="line">    mov ss,cx</span><br><span class="line">    mov esp,0x7c00</span><br><span class="line"></span><br><span class="line">    mov ebp,esp ;保存堆栈指针</span><br><span class="line">    push byte &#x27;.&#x27; ;压入立即数（字节）</span><br><span class="line"></span><br><span class="line">    sub ebp,4</span><br><span class="line">    cmp ebp,esp ;判断压入立即数时，ESP是否减4</span><br><span class="line">    jnz ghalt</span><br><span class="line">    pop eax</span><br><span class="line">    mov [0x1e],al ;显示句点</span><br><span class="line"></span><br><span class="line">ghalt:</span><br><span class="line">    hlt ;已经禁止中断，将不会被唤醒</span><br><span class="line"></span><br><span class="line">    ;-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    gdt_size dw 0</span><br><span class="line">    gdt_base dd 0x00007e00 ;GDT的物理地址</span><br><span class="line"></span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a class="header-anchor" href="#冒泡排序">¶</a>冒泡排序</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;冒泡排序</span><br><span class="line">;===================================================================</span><br><span class="line">    ;设置堆栈段和栈指针</span><br><span class="line">    mov eax,cs</span><br><span class="line">    mov ss,eax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">    ;计算GDT所在的逻辑段地址</span><br><span class="line">    mov eax,[cs:pgdt+0x7c00+0x02] ;GDT的32位线性基地址</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov ebx,16</span><br><span class="line">    div ebx ;分解成16位逻辑地址</span><br><span class="line"></span><br><span class="line">    mov ds,eax ;令DS指向该段以进行操作</span><br><span class="line">    mov ebx,edx ;段内起始偏移地址</span><br><span class="line"></span><br><span class="line">    ;创建0#描述符，它是空描述符，这是处理器的要求</span><br><span class="line">    mov dword [ebx+0x00],0x00000000</span><br><span class="line">    mov dword [ebx+0x04],0x00000000</span><br><span class="line"></span><br><span class="line">    ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">    mov dword [ebx+0x08],0x0000ffff ;基地址为0，段界限为0xfffff</span><br><span class="line">    mov dword [ebx+0x0c],0x00cf9200 ;粒度为4KB，存储器段描述符</span><br><span class="line"></span><br><span class="line">    ;创建保护模式下初始代码段描述符</span><br><span class="line">    mov dword [ebx+0x10],0x7c0001ff ;基地址为0x00007c00，512字节</span><br><span class="line">    mov dword [ebx+0x14],0x00409800 ;粒度为1个字节，代码段描述符</span><br><span class="line"></span><br><span class="line">    ;创建以上代码段的别名描述符</span><br><span class="line">    mov dword [ebx+0x18],0x7c0001ff ;基地址为0x00007c00，512字节</span><br><span class="line">    mov dword [ebx+0x1c],0x00409200 ;粒度为1个字节，数据段描述符</span><br><span class="line"></span><br><span class="line">    mov dword [ebx+0x20],0x7c00fffe</span><br><span class="line">    mov dword [ebx+0x24],0x00cf9600</span><br><span class="line"></span><br><span class="line">    ;初始化描述符表寄存器GDTR</span><br><span class="line">    mov word [cs: pgdt+0x7c00],39 ;描述符表的界限</span><br><span class="line"></span><br><span class="line">    lgdt [cs: pgdt+0x7c00]</span><br><span class="line"></span><br><span class="line">    in al,0x92 ;南桥芯片内的端口</span><br><span class="line">    or al,0000_0010B</span><br><span class="line">    out 0x92,al ;打开A20</span><br><span class="line"></span><br><span class="line">    cli ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or eax,1</span><br><span class="line">    mov cr0,eax ;设置PE位</span><br><span class="line"></span><br><span class="line">    ;以下进入保护模式... ...</span><br><span class="line">    jmp dword 0x0010:flush ;16位的描述符选择子：32位偏移</span><br><span class="line"></span><br><span class="line">    [bits 32]</span><br><span class="line">flush:</span><br><span class="line">    mov eax,0x0018</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov eax,0x0008 ;加载数据段(0..4GB)选择子</span><br><span class="line">    mov es,eax</span><br><span class="line">    mov fs,eax</span><br><span class="line">    mov gs,eax</span><br><span class="line"></span><br><span class="line">    mov eax,0x0020 ;0000 0000 0010 0000</span><br><span class="line">    mov ss,eax</span><br><span class="line">    xor esp,esp ;ESP &lt;- 0</span><br><span class="line"></span><br><span class="line">    mov dword [es:0x0b8000],0x072e0750 ;字符&#x27;P&#x27;、&#x27;.&#x27;及其显示属性</span><br><span class="line">    mov dword [es:0x0b8004],0x072e074d ;字符&#x27;M&#x27;、&#x27;.&#x27;及其显示属性</span><br><span class="line">    mov dword [es:0x0b8008],0x07200720 ;两个空白字符及其显示属性</span><br><span class="line">    mov dword [es:0x0b800c],0x076b076f ;字符&#x27;o&#x27;、&#x27;k&#x27;及其显示属性</span><br><span class="line"></span><br><span class="line">    ;开始冒泡排序</span><br><span class="line">    mov ecx,pgdt-string-1 ;遍历次数=串长度-1</span><br><span class="line">@@1:</span><br><span class="line">    push ecx ;32位模式下的loop使用ecx</span><br><span class="line">    xor bx,bx ;32位模式下，偏移量可以是16位，也可以</span><br><span class="line">@@2: ;是后面的32位</span><br><span class="line">    mov ax,[string+bx]</span><br><span class="line">    cmp ah,al ;ah中存放的是源字的高字节</span><br><span class="line">    jge @@3</span><br><span class="line">    xchg al,ah</span><br><span class="line">    mov [string+bx],ax</span><br><span class="line">@@3:</span><br><span class="line">    inc bx</span><br><span class="line">    loop @@2</span><br><span class="line">    pop ecx</span><br><span class="line">    loop @@1</span><br><span class="line"></span><br><span class="line">    mov ecx,pgdt-string</span><br><span class="line">    xor ebx,ebx ;偏移地址是32位的情况</span><br><span class="line">@@4: ;32位的偏移具有更大的灵活性</span><br><span class="line">    mov ah,0x07</span><br><span class="line">    mov al,[string+ebx]</span><br><span class="line">    mov [es:0xb80a0+ebx*2],ax ;演示0~4GB寻址。</span><br><span class="line">    inc ebx</span><br><span class="line">    loop @@4</span><br><span class="line"></span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">    ;-------------------------------------------------------------------------------</span><br><span class="line">    string db &#x27;s0ke4or92xap3fv8giuzjcy5l1m7hd6bnqtw.&#x27;</span><br><span class="line">    ;-------------------------------------------------------------------------------</span><br><span class="line">    pgdt dw 0</span><br><span class="line">    dd 0x00007e00 ;GDT的物理地址</span><br><span class="line">    ;-------------------------------------------------------------------------------</span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<h3 id="保护模式程序的动态加载和执行"><a class="header-anchor" href="#保护模式程序的动态加载和执行">¶</a>保护模式程序的动态加载和执行</h3>
<h4 id="主引导程序"><a class="header-anchor" href="#主引导程序">¶</a>主引导程序</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    core_base_address equ 0x00040000 ;常数，内核加载的起始内存地址</span><br><span class="line">    core_start_sector equ 0x00000001 ;常数，内核的起始逻辑扇区号</span><br><span class="line"></span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,0x7c00</span><br><span class="line"></span><br><span class="line">    ;计算GDT所在的逻辑段地址</span><br><span class="line">    mov eax,[cs:pgdt+0x7c00+0x02] ;GDT的32位物理地址</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov ebx,16</span><br><span class="line">    div ebx ;分解成16位逻辑地址</span><br><span class="line"></span><br><span class="line">    mov ds,eax ;令DS指向该段以进行操作</span><br><span class="line">    mov ebx,edx ;段内起始偏移地址</span><br><span class="line"></span><br><span class="line">    ;跳过0#号描述符的槽位</span><br><span class="line">    ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间</span><br><span class="line">    mov dword [ebx+0x08],0x0000ffff ;基地址为0，段界限为0xFFFFF</span><br><span class="line">    mov dword [ebx+0x0c],0x00cf9200 ;粒度为4KB，存储器段描述符</span><br><span class="line"></span><br><span class="line">    ;创建保护模式下初始代码段描述符</span><br><span class="line">    mov dword [ebx+0x10],0x7c0001ff ;基地址为0x00007c00，界限0x1FF</span><br><span class="line">    mov dword [ebx+0x14],0x00409800 ;粒度为1个字节，代码段描述符</span><br><span class="line"></span><br><span class="line">    ;建立保护模式下的堆栈段描述符 ;基地址为0x00007C00，界限0xFFFFE</span><br><span class="line">    mov dword [ebx+0x18],0x7c00fffe ;粒度为4KB</span><br><span class="line">    mov dword [ebx+0x1c],0x00cf9600</span><br><span class="line"></span><br><span class="line">    ;建立保护模式下的显示缓冲区描述符</span><br><span class="line">    mov dword [ebx+0x20],0x80007fff ;基地址为0x000B8000，界限0x07FFF</span><br><span class="line">    mov dword [ebx+0x24],0x0040920b ;粒度为字节</span><br><span class="line"></span><br><span class="line">    ;初始化描述符表寄存器GDTR</span><br><span class="line">    mov word [cs: pgdt+0x7c00],39 ;描述符表的界限</span><br><span class="line"></span><br><span class="line">    lgdt [cs: pgdt+0x7c00]</span><br><span class="line"></span><br><span class="line">    in al,0x92 ;南桥芯片内的端口</span><br><span class="line">    or al,0000_0010B</span><br><span class="line">    out 0x92,al ;打开A20</span><br><span class="line"></span><br><span class="line">    cli ;中断机制尚未工作</span><br><span class="line"></span><br><span class="line">    mov eax,cr0</span><br><span class="line">    or eax,1</span><br><span class="line">    mov cr0,eax ;设置PE位</span><br><span class="line"></span><br><span class="line">    ;以下进入保护模式... ...</span><br><span class="line">    jmp dword 0x0010:flush ;16位的描述符选择子：32位偏移</span><br><span class="line">    ;清流水线并串行化处理器</span><br><span class="line">    [bits 32]</span><br><span class="line">flush:</span><br><span class="line">    mov eax,0x0008 ;加载数据段(0..4GB)选择子</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov eax,0x0018 ;加载堆栈段选择子</span><br><span class="line">    mov ss,eax</span><br><span class="line">    xor esp,esp ;堆栈指针 &lt;- 0</span><br><span class="line"></span><br><span class="line">    ;以下加载系统核心程序</span><br><span class="line">    mov edi,core_base_address</span><br><span class="line"></span><br><span class="line">    mov eax,core_start_sector</span><br><span class="line">    mov ebx,edi ;起始地址</span><br><span class="line">    call read_hard_disk_0 ;以下读取程序的起始部分（一个扇区）</span><br><span class="line"></span><br><span class="line">    ;以下判断整个程序有多大</span><br><span class="line">    mov eax,[edi] ;核心程序尺寸</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov ecx,512 ;512字节每扇区</span><br><span class="line">    div ecx</span><br><span class="line"></span><br><span class="line">    or edx,edx</span><br><span class="line">    jnz @1 ;未除尽，因此结果比实际扇区数少1</span><br><span class="line">    dec eax ;已经读了一个扇区，扇区总数减1</span><br><span class="line">@1:</span><br><span class="line">    or eax,eax ;考虑实际长度≤512个字节的情况</span><br><span class="line">    jz setup ;EAX=0 ?</span><br><span class="line"></span><br><span class="line">    ;读取剩余的扇区</span><br><span class="line">    mov ecx,eax ;32位模式下的LOOP使用ECX</span><br><span class="line">    mov eax,core_start_sector</span><br><span class="line">    inc eax ;从下一个逻辑扇区接着读</span><br><span class="line">@2:</span><br><span class="line">    call read_hard_disk_0</span><br><span class="line">    inc eax</span><br><span class="line">    loop @2 ;循环读，直到读完整个内核</span><br><span class="line"></span><br><span class="line">setup:</span><br><span class="line">    mov esi,[0x7c00+pgdt+0x02] ;不可以在代码段内寻址pgdt，但可以</span><br><span class="line">    ;通过4GB的段来访问</span><br><span class="line">    ;建立公用例程段描述符</span><br><span class="line">    mov eax,[edi+0x04] ;公用例程代码段起始汇编地址</span><br><span class="line">    mov ebx,[edi+0x08] ;核心数据段汇编地址</span><br><span class="line">    sub ebx,eax</span><br><span class="line">    dec ebx ;公用例程段界限</span><br><span class="line">    add eax,edi ;公用例程段基地址</span><br><span class="line">    mov ecx,0x00409800 ;字节粒度的代码段描述符</span><br><span class="line">    call make_gdt_descriptor</span><br><span class="line">    mov [esi+0x28],eax</span><br><span class="line">    mov [esi+0x2c],edx</span><br><span class="line"></span><br><span class="line">    ;建立核心数据段描述符</span><br><span class="line">    mov eax,[edi+0x08] ;核心数据段起始汇编地址</span><br><span class="line">    mov ebx,[edi+0x0c] ;核心代码段汇编地址</span><br><span class="line">    sub ebx,eax</span><br><span class="line">    dec ebx ;核心数据段界限</span><br><span class="line">    add eax,edi ;核心数据段基地址</span><br><span class="line">    mov ecx,0x00409200 ;字节粒度的数据段描述符</span><br><span class="line">    call make_gdt_descriptor</span><br><span class="line">    mov [esi+0x30],eax</span><br><span class="line">    mov [esi+0x34],edx</span><br><span class="line"></span><br><span class="line">    ;建立核心代码段描述符</span><br><span class="line">    mov eax,[edi+0x0c] ;核心代码段起始汇编地址</span><br><span class="line">    mov ebx,[edi+0x00] ;程序总长度</span><br><span class="line">    sub ebx,eax</span><br><span class="line">    dec ebx ;核心代码段界限</span><br><span class="line">    add eax,edi ;核心代码段基地址</span><br><span class="line">    mov ecx,0x00409800 ;字节粒度的代码段描述符</span><br><span class="line">    call make_gdt_descriptor</span><br><span class="line">    mov [esi+0x38],eax</span><br><span class="line">    mov [esi+0x3c],edx</span><br><span class="line"></span><br><span class="line">    mov word [0x7c00+pgdt],63 ;描述符表的界限</span><br><span class="line"></span><br><span class="line">    lgdt [0x7c00+pgdt]</span><br><span class="line"></span><br><span class="line">    jmp far [edi+0x10]</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0: ;从硬盘读取一个逻辑扇区</span><br><span class="line">    ;EAX=逻辑扇区号</span><br><span class="line">    ;DS:EBX=目标缓冲区地址</span><br><span class="line">    ;返回：EBX=EBX+512</span><br><span class="line">    push eax</span><br><span class="line">    push ecx</span><br><span class="line">    push edx</span><br><span class="line"></span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    mov dx,0x1f2</span><br><span class="line">    mov al,1</span><br><span class="line">    out dx,al ;读取的扇区数</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f3</span><br><span class="line">    pop eax</span><br><span class="line">    out dx,al ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f4</span><br><span class="line">    mov cl,8</span><br><span class="line">    shr eax,cl</span><br><span class="line">    out dx,al ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f5</span><br><span class="line">    shr eax,cl</span><br><span class="line">    out dx,al ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f6</span><br><span class="line">    shr eax,cl</span><br><span class="line">    or al,0xe0 ;第一硬盘 LBA地址27~24</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f7</span><br><span class="line">    mov al,0x20 ;读命令</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">.waits:</span><br><span class="line">    in al,dx</span><br><span class="line">    and al,0x88</span><br><span class="line">    cmp al,0x08</span><br><span class="line">    jnz .waits ;不忙，且硬盘已准备好数据传输</span><br><span class="line"></span><br><span class="line">    mov ecx,256 ;总共要读取的字数</span><br><span class="line">    mov dx,0x1f0</span><br><span class="line">.readw:</span><br><span class="line">    in ax,dx</span><br><span class="line">    mov [ebx],ax</span><br><span class="line">    add ebx,2</span><br><span class="line">    loop .readw</span><br><span class="line"></span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    pop eax</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">make_gdt_descriptor: ;构造描述符</span><br><span class="line">    ;输入：EAX=线性基地址</span><br><span class="line">    ; EBX=段界限</span><br><span class="line">    ; ECX=属性（各属性位都在原始</span><br><span class="line">    ; 位置，其它没用到的位置0）</span><br><span class="line">    ;返回：EDX:EAX=完整的描述符</span><br><span class="line">    mov edx,eax</span><br><span class="line">    shl eax,16</span><br><span class="line">    or ax,bx ;描述符前32位(EAX)构造完毕</span><br><span class="line"></span><br><span class="line">    and edx,0xffff0000 ;清除基地址中无关的位</span><br><span class="line">    rol edx,8</span><br><span class="line">    bswap edx ;装配基址的31~24和23~16 (80486+)</span><br><span class="line"></span><br><span class="line">    xor bx,bx</span><br><span class="line">    or edx,ebx ;装配段界限的高4位</span><br><span class="line"></span><br><span class="line">    or edx,ecx ;装配属性</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">    pgdt dw 0</span><br><span class="line">    dd 0x00007e00 ;GDT的物理地址</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">    times 510-($-$$) db 0</span><br><span class="line">    db 0x55,0xaa</span><br></pre></td></tr></table></figure>
<h4 id="内核程序"><a class="header-anchor" href="#内核程序">¶</a>内核程序</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    ;以下常量定义部分。内核的大部分内容都应当固定</span><br><span class="line">    core_code_seg_sel equ 0x38 ;内核代码段选择子</span><br><span class="line">    core_data_seg_sel equ 0x30 ;内核数据段选择子</span><br><span class="line">    sys_routine_seg_sel equ 0x28 ;系统公共例程代码段的选择子</span><br><span class="line">    video_ram_seg_sel equ 0x20 ;视频显示缓冲区的段选择子</span><br><span class="line">    core_stack_seg_sel equ 0x18 ;内核堆栈段选择子</span><br><span class="line">    mem_0_4_gb_seg_sel equ 0x08 ;整个0-4GB内存的段的选择子</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">    ;以下是系统核心的头部，用于加载核心程序</span><br><span class="line">    core_length dd core_end ;核心程序总长度#00</span><br><span class="line"></span><br><span class="line">    sys_routine_seg dd section.sys_routine.start</span><br><span class="line">    ;系统公用例程段位置#04</span><br><span class="line"></span><br><span class="line">    core_data_seg dd section.core_data.start</span><br><span class="line">    ;核心数据段位置#08</span><br><span class="line"></span><br><span class="line">    core_code_seg dd section.core_code.start</span><br><span class="line">    ;核心代码段位置#0c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    core_entry dd start ;核心代码段入口点#10</span><br><span class="line">    dw core_code_seg_sel</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">[bits 32]</span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION sys_routine vstart=0 ;系统公共例程代码段</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;字符串显示例程</span><br><span class="line">put_string: ;显示0终止的字符串并移动光标</span><br><span class="line">    ;输入：DS:EBX=串地址</span><br><span class="line">    push ecx</span><br><span class="line">.getc:</span><br><span class="line">    mov cl,[ebx]</span><br><span class="line">    or cl,cl</span><br><span class="line">    jz .exit</span><br><span class="line">    call put_char</span><br><span class="line">    inc ebx</span><br><span class="line">    jmp .getc</span><br><span class="line"></span><br><span class="line">.exit:</span><br><span class="line">    pop ecx</span><br><span class="line">    retf ;段间返回</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">put_char: ;在当前光标处显示一个字符,并推进</span><br><span class="line">;光标。仅用于段内调用</span><br><span class="line">;输入：CL=字符ASCII码</span><br><span class="line">    pushad</span><br><span class="line"></span><br><span class="line">    ;以下取当前光标位置</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    inc dx ;0x3d5</span><br><span class="line">    in al,dx ;高字</span><br><span class="line">    mov ah,al</span><br><span class="line"></span><br><span class="line">    dec dx ;0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    inc dx ;0x3d5</span><br><span class="line">    in al,dx ;低字</span><br><span class="line">    mov bx,ax ;BX=代表光标位置的16位数</span><br><span class="line"></span><br><span class="line">    cmp cl,0x0d ;回车符？</span><br><span class="line">    jnz .put_0a</span><br><span class="line">    mov ax,bx</span><br><span class="line">    mov bl,80</span><br><span class="line">    div bl</span><br><span class="line">    mul bl</span><br><span class="line">    mov bx,ax</span><br><span class="line">    jmp .set_cursor</span><br><span class="line"></span><br><span class="line">.put_0a:</span><br><span class="line">    cmp cl,0x0a ;换行符？</span><br><span class="line">    jnz .put_other</span><br><span class="line">    add bx,80</span><br><span class="line">    jmp .roll_screen</span><br><span class="line"></span><br><span class="line">.put_other: ;正常显示字符</span><br><span class="line">    push es</span><br><span class="line">    mov eax,video_ram_seg_sel ;0xb8000段的选择子</span><br><span class="line">    mov es,eax</span><br><span class="line">    shl bx,1</span><br><span class="line">    mov [es:bx],cl</span><br><span class="line">    pop es</span><br><span class="line"></span><br><span class="line">    ;以下将光标位置推进一个字符</span><br><span class="line">    shr bx,1</span><br><span class="line">    inc bx</span><br><span class="line">    .roll_screen:</span><br><span class="line">    cmp bx,2000 ;光标超出屏幕？滚屏</span><br><span class="line">    jl .set_cursor</span><br><span class="line"></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line">    mov eax,video_ram_seg_sel</span><br><span class="line">    mov ds,eax</span><br><span class="line">    mov es,eax</span><br><span class="line">    cld</span><br><span class="line">    mov esi,0xa0 ;小心！32位模式下movsb/w/d</span><br><span class="line">    mov edi,0x00 ;使用的是esi/edi/ecx</span><br><span class="line">    mov ecx,1920</span><br><span class="line">    rep movsd</span><br><span class="line">    mov bx,3840 ;清除屏幕最底一行</span><br><span class="line">    mov ecx,80 ;32位程序应该使用ECX</span><br><span class="line">.cls:</span><br><span class="line">    mov word[es:bx],0x0720</span><br><span class="line">    add bx,2</span><br><span class="line">    loop .cls</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov bx,1920</span><br><span class="line"></span><br><span class="line">.set_cursor:</span><br><span class="line">    mov dx,0x3d4</span><br><span class="line">    mov al,0x0e</span><br><span class="line">    out dx,al</span><br><span class="line">    inc dx ;0x3d5</span><br><span class="line">    mov al,bh</span><br><span class="line">    out dx,al</span><br><span class="line">    dec dx ;0x3d4</span><br><span class="line">    mov al,0x0f</span><br><span class="line">    out dx,al</span><br><span class="line">    inc dx ;0x3d5</span><br><span class="line">    mov al,bl</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    popad</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0: ;从硬盘读取一个逻辑扇区</span><br><span class="line">    ;EAX=逻辑扇区号</span><br><span class="line">    ;DS:EBX=目标缓冲区地址</span><br><span class="line">    ;返回：EBX=EBX+512</span><br><span class="line">    push eax</span><br><span class="line">    push ecx</span><br><span class="line">    push edx</span><br><span class="line"></span><br><span class="line">    push eax</span><br><span class="line"></span><br><span class="line">    mov dx,0x1f2</span><br><span class="line">    mov al,1</span><br><span class="line">    out dx,al ;读取的扇区数</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f3</span><br><span class="line">    pop eax</span><br><span class="line">    out dx,al ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f4</span><br><span class="line">    mov cl,8</span><br><span class="line">    shr eax,cl</span><br><span class="line">    out dx,al ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f5</span><br><span class="line">    shr eax,cl</span><br><span class="line">    out dx,al ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f6</span><br><span class="line">    shr eax,cl</span><br><span class="line">    or al,0xe0 ;第一硬盘 LBA地址27~24</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">    inc dx ;0x1f7</span><br><span class="line">    mov al,0x20 ;读命令</span><br><span class="line">    out dx,al</span><br><span class="line"></span><br><span class="line">.waits:</span><br><span class="line">    in al,dx</span><br><span class="line">    and al,0x88</span><br><span class="line">    cmp al,0x08</span><br><span class="line">    jnz .waits ;不忙，且硬盘已准备好数据传输</span><br><span class="line"></span><br><span class="line">    mov ecx,256 ;总共要读取的字数</span><br><span class="line">    mov dx,0x1f0</span><br><span class="line">.readw:</span><br><span class="line">    in ax,dx</span><br><span class="line">    mov [ebx],ax</span><br><span class="line">    add ebx,2</span><br><span class="line">    loop .readw</span><br><span class="line"></span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    pop eax</span><br><span class="line"></span><br><span class="line">    retf ;段间返回</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助</span><br><span class="line">put_hex_dword: ;在当前光标处以十六进制形式显示</span><br><span class="line">    ;一个双字并推进光标</span><br><span class="line">    ;输入：EDX=要转换并显示的数字</span><br><span class="line">    ;输出：无</span><br><span class="line">    pushad</span><br><span class="line">    push ds</span><br><span class="line"></span><br><span class="line">    mov ax,core_data_seg_sel ;切换到核心数据段</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov ebx,bin_hex ;指向核心数据段内的转换表</span><br><span class="line">    mov ecx,8</span><br><span class="line">.xlt:</span><br><span class="line">    rol edx,4</span><br><span class="line">    mov eax,edx</span><br><span class="line">    and eax,0x0000000f</span><br><span class="line">    xlat</span><br><span class="line"></span><br><span class="line">    push ecx</span><br><span class="line">    mov cl,al</span><br><span class="line">    call put_char</span><br><span class="line">    pop ecx</span><br><span class="line"></span><br><span class="line">    loop .xlt</span><br><span class="line"></span><br><span class="line">    pop ds</span><br><span class="line">    popad</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">allocate_memory: ;分配内存</span><br><span class="line">    ;输入：ECX=希望分配的字节数</span><br><span class="line">    ;输出：ECX=起始线性地址</span><br><span class="line">    push ds</span><br><span class="line">    push eax</span><br><span class="line">    push ebx</span><br><span class="line"></span><br><span class="line">    mov eax,core_data_seg_sel</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov eax,[ram_alloc]</span><br><span class="line">    add eax,ecx ;下一次分配时的起始地址</span><br><span class="line"></span><br><span class="line">    ;这里应当有检测可用内存数量的指令</span><br><span class="line"></span><br><span class="line">    mov ecx,[ram_alloc] ;返回分配的起始地址</span><br><span class="line"></span><br><span class="line">    mov ebx,eax</span><br><span class="line">    and ebx,0xfffffffc</span><br><span class="line">    add ebx,4 ;强制对齐</span><br><span class="line">    test eax,0x00000003 ;下次分配的起始地址最好是4字节对齐</span><br><span class="line">    cmovnz eax,ebx ;如果没有对齐，则强制对齐</span><br><span class="line">    mov [ram_alloc],eax ;下次从该地址分配内存</span><br><span class="line">    ;cmovcc指令可以避免控制转移</span><br><span class="line">    pop ebx</span><br><span class="line">    pop eax</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">set_up_gdt_descriptor: ;在GDT内安装一个新的描述符</span><br><span class="line">    ;输入：EDX:EAX=描述符</span><br><span class="line">    ;输出：CX=描述符的选择子</span><br><span class="line">    push eax</span><br><span class="line">    push ebx</span><br><span class="line">    push edx</span><br><span class="line"></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    mov ebx,core_data_seg_sel ;切换到核心数据段</span><br><span class="line">    mov ds,ebx</span><br><span class="line"></span><br><span class="line">    sgdt [pgdt] ;以便开始处理GDT</span><br><span class="line"></span><br><span class="line">    mov ebx,mem_0_4_gb_seg_sel</span><br><span class="line">    mov es,ebx</span><br><span class="line"></span><br><span class="line">    movzx ebx,word [pgdt] ;GDT界限</span><br><span class="line">    inc bx ;GDT总字节数，也是下一个描述符偏移</span><br><span class="line">    add ebx,[pgdt+2] ;下一个描述符的线性地址</span><br><span class="line"></span><br><span class="line">    mov [es:ebx],eax</span><br><span class="line">    mov [es:ebx+4],edx</span><br><span class="line"></span><br><span class="line">    add word [pgdt],8 ;增加一个描述符的大小</span><br><span class="line"></span><br><span class="line">    lgdt [pgdt] ;对GDT的更改生效</span><br><span class="line"></span><br><span class="line">    mov ax,[pgdt] ;得到GDT界限值</span><br><span class="line">    xor dx,dx</span><br><span class="line">    mov bx,8</span><br><span class="line">    div bx ;除以8，去掉余数</span><br><span class="line">    mov cx,ax</span><br><span class="line">    shl cx,3 ;将索引号移到正确位置</span><br><span class="line"></span><br><span class="line">    pop es</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    pop edx</span><br><span class="line">    pop ebx</span><br><span class="line">    pop eax</span><br><span class="line"></span><br><span class="line">    retf</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">make_seg_descriptor: ;构造存储器和系统的段描述符</span><br><span class="line">    ;输入：EAX=线性基地址</span><br><span class="line">    ; EBX=段界限</span><br><span class="line">    ; ECX=属性。各属性位都在原始</span><br><span class="line">    ; 位置，无关的位清零</span><br><span class="line">    ;返回：EDX:EAX=描述符</span><br><span class="line">    mov edx,eax</span><br><span class="line">    shl eax,16</span><br><span class="line">    or ax,bx ;描述符前32位(EAX)构造完毕</span><br><span class="line"></span><br><span class="line">    and edx,0xffff0000 ;清除基地址中无关的位</span><br><span class="line">    rol edx,8</span><br><span class="line">    bswap edx ;装配基址的31~24和23~16 (80486+)</span><br><span class="line"></span><br><span class="line">    xor bx,bx</span><br><span class="line">    or edx,ebx ;装配段界限的高4位</span><br><span class="line"></span><br><span class="line">    or edx,ecx ;装配属性</span><br><span class="line"></span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION core_data vstart=0 ;系统核心的数据段</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">    pgdt dw 0 ;用于设置和修改GDT</span><br><span class="line">    dd 0</span><br><span class="line"></span><br><span class="line">    ram_alloc dd 0x00100000 ;下次分配内存时的起始地址</span><br><span class="line"></span><br><span class="line">;符号地址检索表</span><br><span class="line">salt:</span><br><span class="line">    salt_1 db &#x27;@PrintString&#x27;</span><br><span class="line">    times 256-($-salt_1) db 0</span><br><span class="line">    dd put_string</span><br><span class="line">    dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">    salt_2 db &#x27;@ReadDiskData&#x27;</span><br><span class="line">    times 256-($-salt_2) db 0</span><br><span class="line">    dd read_hard_disk_0</span><br><span class="line">    dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">    salt_3 db &#x27;@PrintDwordAsHexString&#x27;</span><br><span class="line">    times 256-($-salt_3) db 0</span><br><span class="line">    dd put_hex_dword</span><br><span class="line">    dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">    salt_4 db &#x27;@TerminateProgram&#x27;</span><br><span class="line">    times 256-($-salt_4) db 0</span><br><span class="line">    dd return_point</span><br><span class="line">    dw core_code_seg_sel</span><br><span class="line"></span><br><span class="line">    salt_item_len equ $-salt_4</span><br><span class="line">    salt_items equ ($-salt)/salt_item_len</span><br><span class="line"></span><br><span class="line">    message_1 db &#x27; If you seen this message,that means we &#x27;</span><br><span class="line">    db &#x27;are now in protect mode,and the system &#x27;</span><br><span class="line">    db &#x27;core is loaded,and the video display &#x27;</span><br><span class="line">    db &#x27;routine works perfectly.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">    message_5 db &#x27; Loading user program...&#x27;,0</span><br><span class="line"></span><br><span class="line">    do_status db &#x27;Done.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">    message_6 db 0x0d,0x0a,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">    db &#x27; User program terminated,control returned.&#x27;,0</span><br><span class="line"></span><br><span class="line">    bin_hex db &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">    ;put_hex_dword子过程用的查找表</span><br><span class="line">    core_buf times 2048 db 0 ;内核用的缓冲区</span><br><span class="line"></span><br><span class="line">    esp_pointer dd 0 ;内核用来临时保存自己的栈指针</span><br><span class="line"></span><br><span class="line">    cpu_brnd0 db 0x0d,0x0a,&#x27; &#x27;,0</span><br><span class="line">    cpu_brand times 52 db 0</span><br><span class="line">    cpu_brnd1 db 0x0d,0x0a,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION core_code vstart=0</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">load_relocate_program: ;加载并重定位用户程序</span><br><span class="line">    ;输入：ESI=起始逻辑扇区号</span><br><span class="line">    ;返回：AX=指向用户程序头部的选择子</span><br><span class="line">    push ebx</span><br><span class="line">    push ecx</span><br><span class="line">    push edx</span><br><span class="line">    push esi</span><br><span class="line">    push edi</span><br><span class="line"></span><br><span class="line">    push ds</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    mov eax,core_data_seg_sel</span><br><span class="line">    mov ds,eax ;切换DS到内核数据段</span><br><span class="line"></span><br><span class="line">    mov eax,esi ;读取程序头部数据</span><br><span class="line">    mov ebx,core_buf</span><br><span class="line">    call sys_routine_seg_sel:read_hard_disk_0</span><br><span class="line"></span><br><span class="line">    ;以下判断整个程序有多大</span><br><span class="line">    mov eax,[core_buf] ;程序尺寸</span><br><span class="line">    mov ebx,eax</span><br><span class="line">    and ebx,0xfffffe00 ;使之512字节对齐（能被512整除的数，</span><br><span class="line">    add ebx,512 ;低9位都为0</span><br><span class="line">    test eax,0x000001ff ;程序的大小正好是512的倍数吗?</span><br><span class="line">    cmovnz eax,ebx ;不是。使用凑整的结果</span><br><span class="line"></span><br><span class="line">    mov ecx,eax ;实际需要申请的内存数量</span><br><span class="line">    call sys_routine_seg_sel:allocate_memory</span><br><span class="line">    mov ebx,ecx ;ebx -&gt; 申请到的内存首地址</span><br><span class="line">    push ebx ;保存该首地址</span><br><span class="line">    xor edx,edx</span><br><span class="line">    mov ecx,512</span><br><span class="line">    div ecx</span><br><span class="line">    mov ecx,eax ;总扇区数</span><br><span class="line"></span><br><span class="line">    mov eax,mem_0_4_gb_seg_sel ;切换DS到0-4GB的段</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov eax,esi ;起始扇区号</span><br><span class="line">.b1:</span><br><span class="line">    call sys_routine_seg_sel:read_hard_disk_0</span><br><span class="line">    inc eax</span><br><span class="line">    loop .b1 ;循环读，直到读完整个用户程序</span><br><span class="line"></span><br><span class="line">    ;建立程序头部段描述符</span><br><span class="line">    pop edi ;恢复程序装载的首地址</span><br><span class="line">    mov eax,edi ;程序头部起始线性地址</span><br><span class="line">    mov ebx,[edi+0x04] ;段长度</span><br><span class="line">    dec ebx ;段界限</span><br><span class="line">    mov ecx,0x00409200 ;字节粒度的数据段描述符</span><br><span class="line">    call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">    call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">    mov [edi+0x04],cx</span><br><span class="line"></span><br><span class="line">    ;建立程序代码段描述符</span><br><span class="line">    mov eax,edi</span><br><span class="line">    add eax,[edi+0x14] ;代码起始线性地址</span><br><span class="line">    mov ebx,[edi+0x18] ;段长度</span><br><span class="line">    dec ebx ;段界限</span><br><span class="line">    mov ecx,0x00409800 ;字节粒度的代码段描述符</span><br><span class="line">    call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">    call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">    mov [edi+0x14],cx</span><br><span class="line"></span><br><span class="line">    ;建立程序数据段描述符</span><br><span class="line">    mov eax,edi</span><br><span class="line">    add eax,[edi+0x1c] ;数据段起始线性地址</span><br><span class="line">    mov ebx,[edi+0x20] ;段长度</span><br><span class="line">    dec ebx ;段界限</span><br><span class="line">    mov ecx,0x00409200 ;字节粒度的数据段描述符</span><br><span class="line">    call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">    call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">    mov [edi+0x1c],cx</span><br><span class="line"></span><br><span class="line">    ;建立程序堆栈段描述符</span><br><span class="line">    mov ecx,[edi+0x0c] ;4KB的倍率</span><br><span class="line">    mov ebx,0x000fffff</span><br><span class="line">    sub ebx,ecx ;得到段界限</span><br><span class="line">    mov eax,4096</span><br><span class="line">    mul dword [edi+0x0c]</span><br><span class="line">    mov ecx,eax ;准备为堆栈分配内存</span><br><span class="line">    call sys_routine_seg_sel:allocate_memory</span><br><span class="line">    add eax,ecx ;得到堆栈的高端物理地址</span><br><span class="line">    mov ecx,0x00c09600 ;4KB粒度的堆栈段描述符</span><br><span class="line">    call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">    call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">    mov [edi+0x08],cx</span><br><span class="line"></span><br><span class="line">    ;重定位SALT</span><br><span class="line">    mov eax,[edi+0x04]</span><br><span class="line">    mov es,eax ;es -&gt; 用户程序头部</span><br><span class="line">    mov eax,core_data_seg_sel</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    cld</span><br><span class="line"></span><br><span class="line">    mov ecx,[es:0x24] ;用户程序的SALT条目数</span><br><span class="line">    mov edi,0x28 ;用户程序内的SALT位于头部内0x2c处</span><br><span class="line">.b2:</span><br><span class="line">    push ecx</span><br><span class="line">    push edi</span><br><span class="line"></span><br><span class="line">    mov ecx,salt_items</span><br><span class="line">    mov esi,salt</span><br><span class="line">.b3:</span><br><span class="line">    push edi</span><br><span class="line">    push esi</span><br><span class="line">    push ecx</span><br><span class="line"></span><br><span class="line">    mov ecx,64 ;检索表中，每条目的比较次数</span><br><span class="line">    repe cmpsd ;每次比较4字节</span><br><span class="line">    jnz .b4</span><br><span class="line">    mov eax,[esi] ;若匹配，esi恰好指向其后的地址数据</span><br><span class="line">    mov [es:edi-256],eax ;将字符串改写成偏移地址</span><br><span class="line">    mov ax,[esi+4]</span><br><span class="line">    mov [es:edi-252],ax ;以及段选择子</span><br><span class="line">.b4:</span><br><span class="line"></span><br><span class="line">    pop ecx</span><br><span class="line">    pop esi</span><br><span class="line">    add esi,salt_item_len</span><br><span class="line">    pop edi ;从头比较</span><br><span class="line">    loop .b3</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    add edi,256</span><br><span class="line">    pop ecx</span><br><span class="line">    loop .b2</span><br><span class="line"></span><br><span class="line">    mov ax,[es:0x04]</span><br><span class="line"></span><br><span class="line">    pop es ;恢复到调用此过程前的es段</span><br><span class="line">    pop ds ;恢复到调用此过程前的ds段</span><br><span class="line"></span><br><span class="line">    pop edi</span><br><span class="line">    pop esi</span><br><span class="line">    pop edx</span><br><span class="line">    pop ecx</span><br><span class="line">    pop ebx</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">    mov ecx,core_data_seg_sel ;使ds指向核心数据段</span><br><span class="line">    mov ds,ecx</span><br><span class="line"></span><br><span class="line">    mov ebx,message_1</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">    ;显示处理器品牌信息</span><br><span class="line">    mov eax,0x80000002</span><br><span class="line">    cpuid</span><br><span class="line">    mov [cpu_brand + 0x00],eax</span><br><span class="line">    mov [cpu_brand + 0x04],ebx</span><br><span class="line">    mov [cpu_brand + 0x08],ecx</span><br><span class="line">    mov [cpu_brand + 0x0c],edx</span><br><span class="line"></span><br><span class="line">    mov eax,0x80000003</span><br><span class="line">    cpuid</span><br><span class="line">    mov [cpu_brand + 0x10],eax</span><br><span class="line">    mov [cpu_brand + 0x14],ebx</span><br><span class="line">    mov [cpu_brand + 0x18],ecx</span><br><span class="line">    mov [cpu_brand + 0x1c],edx</span><br><span class="line"></span><br><span class="line">    mov eax,0x80000004</span><br><span class="line">    cpuid</span><br><span class="line">    mov [cpu_brand + 0x20],eax</span><br><span class="line">    mov [cpu_brand + 0x24],ebx</span><br><span class="line">    mov [cpu_brand + 0x28],ecx</span><br><span class="line">    mov [cpu_brand + 0x2c],edx</span><br><span class="line"></span><br><span class="line">    mov ebx,cpu_brnd0</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line">    mov ebx,cpu_brand</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line">    mov ebx,cpu_brnd1</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">    mov ebx,message_5</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line">    mov esi,50 ;用户程序位于逻辑50扇区</span><br><span class="line">    call load_relocate_program</span><br><span class="line"></span><br><span class="line">    mov ebx,do_status</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">    mov [esp_pointer],esp ;临时保存堆栈指针</span><br><span class="line"></span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    jmp far [0x10] ;控制权交给用户程序（入口点）</span><br><span class="line">    ;堆栈可能切换</span><br><span class="line"></span><br><span class="line">    return_point: ;用户程序返回点</span><br><span class="line">    mov eax,core_data_seg_sel ;使ds指向核心数据段</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov eax,core_stack_seg_sel ;切换回内核自己的堆栈</span><br><span class="line">    mov ss,eax</span><br><span class="line">    mov esp,[esp_pointer]</span><br><span class="line"></span><br><span class="line">    mov ebx,message_6</span><br><span class="line">    call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">    ;这里可以放置清除用户程序各种描述符的指令</span><br><span class="line">    ;也可以加载并启动其它程序</span><br><span class="line"></span><br><span class="line">    hlt</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION core_trail</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">core_end:</span><br></pre></td></tr></table></figure>
<h4 id="用户程序-2"><a class="header-anchor" href="#用户程序-2">¶</a>用户程序</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;===============================================================================</span><br><span class="line">SECTION header vstart=0</span><br><span class="line"></span><br><span class="line">    program_length dd program_end ;程序总长度#0x00</span><br><span class="line"></span><br><span class="line">    head_len dd header_end ;程序头部的长度#0x04</span><br><span class="line"></span><br><span class="line">    stack_seg dd 0 ;用于接收堆栈段选择子#0x08</span><br><span class="line">    stack_len dd 1 ;程序建议的堆栈大小#0x0c</span><br><span class="line">    ;以4KB为单位</span><br><span class="line"></span><br><span class="line">    prgentry dd start ;程序入口#0x10</span><br><span class="line">    code_seg dd section.code.start ;代码段位置#0x14</span><br><span class="line">    code_len dd code_end ;代码段长度#0x18</span><br><span class="line"></span><br><span class="line">    data_seg dd section.data.start ;数据段位置#0x1c</span><br><span class="line">    data_len dd data_end ;数据段长度#0x20</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">    ;符号地址检索表</span><br><span class="line">    salt_items dd (header_end-salt)/256 ;#0x24</span><br><span class="line"></span><br><span class="line">salt: ;#0x28</span><br><span class="line">    PrintString db &#x27;@PrintString&#x27;</span><br><span class="line">    times 256-($-PrintString) db 0</span><br><span class="line"></span><br><span class="line">    TerminateProgram db &#x27;@TerminateProgram&#x27;</span><br><span class="line">    times 256-($-TerminateProgram) db 0</span><br><span class="line"></span><br><span class="line">    ReadDiskData db &#x27;@ReadDiskData&#x27;</span><br><span class="line">    times 256-($-ReadDiskData) db 0</span><br><span class="line"></span><br><span class="line">header_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">    SECTION data vstart=0</span><br><span class="line"></span><br><span class="line">    buffer times 1024 db 0 ;缓冲区</span><br><span class="line"></span><br><span class="line">    message_1 db 0x0d,0x0a,0x0d,0x0a</span><br><span class="line">    db &#x27;**********User program is runing**********&#x27;</span><br><span class="line">    db 0x0d,0x0a,0</span><br><span class="line">    message_2 db &#x27; Disk data:&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">    data_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">    [bits 32]</span><br><span class="line">;===============================================================================</span><br><span class="line">    SECTION code vstart=0</span><br><span class="line">start:</span><br><span class="line">    mov eax,ds</span><br><span class="line">    mov fs,eax</span><br><span class="line"></span><br><span class="line">    mov eax,[stack_seg]</span><br><span class="line">    mov ss,eax</span><br><span class="line">    mov esp,0</span><br><span class="line"></span><br><span class="line">    mov eax,[data_seg]</span><br><span class="line">    mov ds,eax</span><br><span class="line"></span><br><span class="line">    mov ebx,message_1</span><br><span class="line">    call far [fs:PrintString]</span><br><span class="line"></span><br><span class="line">    mov eax,100 ;逻辑扇区号100</span><br><span class="line">    mov ebx,buffer ;缓冲区偏移地址</span><br><span class="line">    call far [fs:ReadDiskData] ;段间调用</span><br><span class="line"></span><br><span class="line">    mov ebx,message_2</span><br><span class="line">    call far [fs:PrintString]</span><br><span class="line"></span><br><span class="line">    mov ebx,buffer</span><br><span class="line">    call far [fs:PrintString] ;too.</span><br><span class="line"></span><br><span class="line">    jmp far [fs:TerminateProgram] ;将控制权返回到系统</span><br><span class="line"></span><br><span class="line">    code_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">    SECTION trail</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">program_end:</span><br></pre></td></tr></table></figure>
<h3 id="ldt-tss的使用"><a class="header-anchor" href="#ldt-tss的使用">¶</a>ldt tss的使用</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;以下常量定义部分。内核的大部分内容都应当固定</span><br><span class="line">core_code_seg_sel equ 0x38 ;内核代码段选择子</span><br><span class="line">core_data_seg_sel equ 0x30 ;内核数据段选择子</span><br><span class="line">sys_routine_seg_sel equ 0x28 ;系统公共例程代码段的选择子</span><br><span class="line">video_ram_seg_sel equ 0x20 ;视频显示缓冲区的段选择子</span><br><span class="line">core_stack_seg_sel equ 0x18 ;内核堆栈段选择子</span><br><span class="line">mem_0_4_gb_seg_sel equ 0x08 ;整个0-4GB内存的段的选择子</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;以下是系统核心的头部，用于加载核心程序</span><br><span class="line">core_length dd core_end ;核心程序总长度#00</span><br><span class="line">sys_routine_seg dd section.sys_routine.start</span><br><span class="line">;系统公用例程段位置#04</span><br><span class="line">core_data_seg dd section.core_data.start</span><br><span class="line">;核心数据段位置#08</span><br><span class="line">core_code_seg dd section.core_code.start</span><br><span class="line">;核心代码段位置#0c</span><br><span class="line">core_entry dd start ;核心代码段入口点#10</span><br><span class="line">dw core_code_seg_sel</span><br><span class="line">;===============================================================================</span><br><span class="line">[bits 32]</span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION sys_routine vstart=0 ;系统公共例程代码段</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;字符串显示例程</span><br><span class="line">put_string: ;显示0终止的字符串并移动光标</span><br><span class="line">;输入：DS:EBX=串地址</span><br><span class="line">push ecx</span><br><span class="line">.getc:</span><br><span class="line">mov cl,[ebx]</span><br><span class="line">or cl,cl</span><br><span class="line">jz .exit</span><br><span class="line">call put_char</span><br><span class="line">inc ebx</span><br><span class="line">jmp .getc</span><br><span class="line">.exit:</span><br><span class="line">pop ecx</span><br><span class="line">retf ;段间返回</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">put_char: ;在当前光标处显示一个字符,并推进</span><br><span class="line">;光标。仅用于段内调用</span><br><span class="line">;输入：CL=字符ASCII码</span><br><span class="line">pushad</span><br><span class="line">;以下取当前光标位置</span><br><span class="line">mov dx,0x3d4</span><br><span class="line">mov al,0x0e</span><br><span class="line">out dx,al</span><br><span class="line">inc dx ;0x3d5</span><br><span class="line">in al,dx ;高字</span><br><span class="line">mov ah,al</span><br><span class="line">dec dx ;0x3d4</span><br><span class="line">mov al,0x0f</span><br><span class="line">out dx,al</span><br><span class="line">inc dx ;0x3d5</span><br><span class="line">in al,dx ;低字</span><br><span class="line">mov bx,ax ;BX=代表光标位置的16位数</span><br><span class="line">cmp cl,0x0d ;回车符？</span><br><span class="line">jnz .put_0a</span><br><span class="line">mov ax,bx</span><br><span class="line">mov bl,80</span><br><span class="line">div bl</span><br><span class="line">mul bl</span><br><span class="line">mov bx,ax</span><br><span class="line">jmp .set_cursor</span><br><span class="line">.put_0a:</span><br><span class="line">cmp cl,0x0a ;换行符？</span><br><span class="line">jnz .put_other</span><br><span class="line">add bx,80</span><br><span class="line">jmp .roll_screen</span><br><span class="line">.put_other: ;正常显示字符</span><br><span class="line">push es</span><br><span class="line">mov eax,video_ram_seg_sel ;0xb8000段的选择子</span><br><span class="line">mov es,eax</span><br><span class="line">shl bx,1</span><br><span class="line">mov [es:bx],cl</span><br><span class="line">pop es</span><br><span class="line">;以下将光标位置推进一个字符</span><br><span class="line">shr bx,1</span><br><span class="line">inc bx</span><br><span class="line">.roll_screen:</span><br><span class="line">cmp bx,2000 ;光标超出屏幕？滚屏</span><br><span class="line">jl .set_cursor</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line">mov eax,video_ram_seg_sel</span><br><span class="line">mov ds,eax</span><br><span class="line">mov es,eax</span><br><span class="line">cld</span><br><span class="line">mov esi,0xa0 ;小心！32位模式下movsb/w/d</span><br><span class="line">mov edi,0x00 ;使用的是esi/edi/ecx</span><br><span class="line">mov ecx,1920</span><br><span class="line">rep movsd</span><br><span class="line">mov bx,3840 ;清除屏幕最底一行</span><br><span class="line">mov ecx,80 ;32位程序应该使用ECX</span><br><span class="line">.cls:</span><br><span class="line">mov word[es:bx],0x0720</span><br><span class="line">add bx,2</span><br><span class="line">loop .cls</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line"></span><br><span class="line">mov bx,1920</span><br><span class="line"></span><br><span class="line">.set_cursor:</span><br><span class="line">mov dx,0x3d4</span><br><span class="line">mov al,0x0e</span><br><span class="line">out dx,al</span><br><span class="line">inc dx ;0x3d5</span><br><span class="line">mov al,bh</span><br><span class="line">out dx,al</span><br><span class="line">dec dx ;0x3d4</span><br><span class="line">mov al,0x0f</span><br><span class="line">out dx,al</span><br><span class="line">inc dx ;0x3d5</span><br><span class="line">mov al,bl</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">read_hard_disk_0: ;从硬盘读取一个逻辑扇区</span><br><span class="line">;EAX=逻辑扇区号</span><br><span class="line">;DS:EBX=目标缓冲区地址</span><br><span class="line">;返回：EBX=EBX+512</span><br><span class="line">push eax</span><br><span class="line">push ecx</span><br><span class="line">push edx</span><br><span class="line"></span><br><span class="line">push eax</span><br><span class="line"></span><br><span class="line">mov dx,0x1f2</span><br><span class="line">mov al,1</span><br><span class="line">out dx,al ;读取的扇区数</span><br><span class="line"></span><br><span class="line">inc dx ;0x1f3</span><br><span class="line">pop eax</span><br><span class="line">out dx,al ;LBA地址7~0</span><br><span class="line"></span><br><span class="line">inc dx ;0x1f4</span><br><span class="line">mov cl,8</span><br><span class="line">shr eax,cl</span><br><span class="line">out dx,al ;LBA地址15~8</span><br><span class="line"></span><br><span class="line">inc dx ;0x1f5</span><br><span class="line">shr eax,cl</span><br><span class="line">out dx,al ;LBA地址23~16</span><br><span class="line"></span><br><span class="line">inc dx ;0x1f6</span><br><span class="line">shr eax,cl</span><br><span class="line">or al,0xe0 ;第一硬盘 LBA地址27~24</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">inc dx ;0x1f7</span><br><span class="line">mov al,0x20 ;读命令</span><br><span class="line">out dx,al</span><br><span class="line"></span><br><span class="line">.waits:</span><br><span class="line">in al,dx</span><br><span class="line">and al,0x88</span><br><span class="line">cmp al,0x08</span><br><span class="line">jnz .waits ;不忙，且硬盘已准备好数据传输</span><br><span class="line"></span><br><span class="line">mov ecx,256 ;总共要读取的字数</span><br><span class="line">mov dx,0x1f0</span><br><span class="line">.readw:</span><br><span class="line">in ax,dx</span><br><span class="line">mov [ebx],ax</span><br><span class="line">add ebx,2</span><br><span class="line">loop .readw</span><br><span class="line"></span><br><span class="line">pop edx</span><br><span class="line">pop ecx</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">retf ;段间返回</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助</span><br><span class="line">put_hex_dword: ;在当前光标处以十六进制形式显示</span><br><span class="line">;一个双字并推进光标</span><br><span class="line">;输入：EDX=要转换并显示的数字</span><br><span class="line">;输出：无</span><br><span class="line">pushad</span><br><span class="line">push ds</span><br><span class="line"></span><br><span class="line">mov ax,core_data_seg_sel ;切换到核心数据段</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ebx,bin_hex ;指向核心数据段内的转换表</span><br><span class="line">mov ecx,8</span><br><span class="line">.xlt:</span><br><span class="line">rol edx,4</span><br><span class="line">mov eax,edx</span><br><span class="line">and eax,0x0000000f</span><br><span class="line">xlat</span><br><span class="line"></span><br><span class="line">push ecx</span><br><span class="line">mov cl,al</span><br><span class="line">call put_char</span><br><span class="line">pop ecx</span><br><span class="line"></span><br><span class="line">loop .xlt</span><br><span class="line"></span><br><span class="line">pop ds</span><br><span class="line">popad</span><br><span class="line">retf</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">allocate_memory: ;分配内存</span><br><span class="line">;输入：ECX=希望分配的字节数</span><br><span class="line">;输出：ECX=起始线性地址</span><br><span class="line">push ds</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line"></span><br><span class="line">mov eax,core_data_seg_sel</span><br><span class="line">mov ds,eax</span><br><span class="line"></span><br><span class="line">mov eax,[ram_alloc]</span><br><span class="line">add eax,ecx ;下一次分配时的起始地址</span><br><span class="line"></span><br><span class="line">;这里应当有检测可用内存数量的指令</span><br><span class="line"></span><br><span class="line">mov ecx,[ram_alloc] ;返回分配的起始地址</span><br><span class="line"></span><br><span class="line">mov ebx,eax</span><br><span class="line">and ebx,0xfffffffc</span><br><span class="line">add ebx,4 ;强制对齐</span><br><span class="line">test eax,0x00000003 ;下次分配的起始地址最好是4字节对齐</span><br><span class="line">cmovnz eax,ebx ;如果没有对齐，则强制对齐</span><br><span class="line">mov [ram_alloc],eax ;下次从该地址分配内存</span><br><span class="line">;cmovcc指令可以避免控制转移</span><br><span class="line">pop ebx</span><br><span class="line">pop eax</span><br><span class="line">pop ds</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">set_up_gdt_descriptor: ;在GDT内安装一个新的描述符</span><br><span class="line">;输入：EDX:EAX=描述符</span><br><span class="line">;输出：CX=描述符的选择子</span><br><span class="line">push eax</span><br><span class="line">push ebx</span><br><span class="line">push edx</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ebx,core_data_seg_sel ;切换到核心数据段</span><br><span class="line">mov ds,ebx</span><br><span class="line"></span><br><span class="line">sgdt [pgdt] ;以便开始处理GDT</span><br><span class="line"></span><br><span class="line">mov ebx,mem_0_4_gb_seg_sel</span><br><span class="line">mov es,ebx</span><br><span class="line"></span><br><span class="line">movzx ebx,word [pgdt] ;GDT界限</span><br><span class="line">inc bx ;GDT总字节数，也是下一个描述符偏移</span><br><span class="line">add ebx,[pgdt+2] ;下一个描述符的线性地址</span><br><span class="line"></span><br><span class="line">mov [es:ebx],eax</span><br><span class="line">mov [es:ebx+4],edx</span><br><span class="line"></span><br><span class="line">add word [pgdt],8 ;增加一个描述符的大小</span><br><span class="line"></span><br><span class="line">lgdt [pgdt] ;对GDT的更改生效</span><br><span class="line"></span><br><span class="line">mov ax,[pgdt] ;得到GDT界限值</span><br><span class="line">xor dx,dx</span><br><span class="line">mov bx,8</span><br><span class="line">div bx ;除以8，去掉余数</span><br><span class="line">mov cx,ax</span><br><span class="line">shl cx,3 ;将索引号移到正确位置</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line"></span><br><span class="line">pop edx</span><br><span class="line">pop ebx</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">make_seg_descriptor: ;构造存储器和系统的段描述符</span><br><span class="line">;输入：EAX=线性基地址</span><br><span class="line">; EBX=段界限</span><br><span class="line">; ECX=属性。各属性位都在原始</span><br><span class="line">; 位置，无关的位清零</span><br><span class="line">;返回：EDX:EAX=描述符</span><br><span class="line">mov edx,eax</span><br><span class="line">shl eax,16</span><br><span class="line">or ax,bx ;描述符前32位(EAX)构造完毕</span><br><span class="line"></span><br><span class="line">and edx,0xffff0000 ;清除基地址中无关的位</span><br><span class="line">rol edx,8</span><br><span class="line">bswap edx ;装配基址的31~24和23~16 (80486+)</span><br><span class="line"></span><br><span class="line">xor bx,bx</span><br><span class="line">or edx,ebx ;装配段界限的高4位</span><br><span class="line"></span><br><span class="line">or edx,ecx ;装配属性</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">make_gate_descriptor: ;构造门的描述符（调用门等）</span><br><span class="line">;输入：EAX=门代码在段内偏移地址</span><br><span class="line">; BX=门代码所在段的选择子</span><br><span class="line">; CX=段类型及属性等（各属</span><br><span class="line">; 性位都在原始位置）</span><br><span class="line">;返回：EDX:EAX=完整的描述符</span><br><span class="line">push ebx</span><br><span class="line">push ecx</span><br><span class="line"></span><br><span class="line">mov edx,eax</span><br><span class="line">and edx,0xffff0000 ;得到偏移地址高16位</span><br><span class="line">or dx,cx ;组装属性部分到EDX</span><br><span class="line"></span><br><span class="line">and eax,0x0000ffff ;得到偏移地址低16位</span><br><span class="line">shl ebx,16</span><br><span class="line">or eax,ebx ;组装段选择子部分</span><br><span class="line"></span><br><span class="line">pop ecx</span><br><span class="line">pop ebx</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line"></span><br><span class="line">sys_routine_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION core_data vstart=0 ;系统核心的数据段</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">pgdt dw 0 ;用于设置和修改GDT</span><br><span class="line">dd 0</span><br><span class="line"></span><br><span class="line">ram_alloc dd 0x00100000 ;下次分配内存时的起始地址</span><br><span class="line"></span><br><span class="line">;符号地址检索表</span><br><span class="line">salt:</span><br><span class="line">salt_1 db &#x27;@PrintString&#x27;</span><br><span class="line">times 256-($-salt_1) db 0</span><br><span class="line">dd put_string</span><br><span class="line">dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">salt_2 db &#x27;@ReadDiskData&#x27;</span><br><span class="line">times 256-($-salt_2) db 0</span><br><span class="line">dd read_hard_disk_0</span><br><span class="line">dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">salt_3 db &#x27;@PrintDwordAsHexString&#x27;</span><br><span class="line">times 256-($-salt_3) db 0</span><br><span class="line">dd put_hex_dword</span><br><span class="line">dw sys_routine_seg_sel</span><br><span class="line"></span><br><span class="line">salt_4 db &#x27;@TerminateProgram&#x27;</span><br><span class="line">times 256-($-salt_4) db 0</span><br><span class="line">dd return_point</span><br><span class="line">dw core_code_seg_sel</span><br><span class="line"></span><br><span class="line">salt_item_len equ $-salt_4</span><br><span class="line">salt_items equ ($-salt)/salt_item_len</span><br><span class="line"></span><br><span class="line">message_1 db &#x27; If you seen this message,that means we &#x27;</span><br><span class="line">db &#x27;are now in protect mode,and the system &#x27;</span><br><span class="line">db &#x27;core is loaded,and the video display &#x27;</span><br><span class="line">db &#x27;routine works perfectly.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">message_2 db &#x27; System wide CALL-GATE mounted.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">message_3 db 0x0d,0x0a,&#x27; Loading user program...&#x27;,0</span><br><span class="line"></span><br><span class="line">do_status db &#x27;Done.&#x27;,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">message_6 db 0x0d,0x0a,0x0d,0x0a,0x0d,0x0a</span><br><span class="line">db &#x27; User program terminated,control returned.&#x27;,0</span><br><span class="line"></span><br><span class="line">bin_hex db &#x27;0123456789ABCDEF&#x27;</span><br><span class="line">;put_hex_dword子过程用的查找表</span><br><span class="line"></span><br><span class="line">core_buf times 2048 db 0 ;内核用的缓冲区</span><br><span class="line"></span><br><span class="line">esp_pointer dd 0 ;内核用来临时保存自己的栈指针</span><br><span class="line"></span><br><span class="line">cpu_brnd0 db 0x0d,0x0a,&#x27; &#x27;,0</span><br><span class="line">cpu_brand times 52 db 0</span><br><span class="line">cpu_brnd1 db 0x0d,0x0a,0x0d,0x0a,0</span><br><span class="line"></span><br><span class="line">;任务控制块链</span><br><span class="line">tcb_chain dd 0</span><br><span class="line"></span><br><span class="line">core_data_end:</span><br><span class="line"></span><br><span class="line">;===============================================================================</span><br><span class="line">SECTION core_code vstart=0</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">fill_descriptor_in_ldt: ;在LDT内安装一个新的描述符</span><br><span class="line">;输入：EDX:EAX=描述符</span><br><span class="line">; EBX=TCB基地址</span><br><span class="line">;输出：CX=描述符的选择子</span><br><span class="line">push eax</span><br><span class="line">push edx</span><br><span class="line">push edi</span><br><span class="line">push ds</span><br><span class="line"></span><br><span class="line">mov ecx,mem_0_4_gb_seg_sel</span><br><span class="line">mov ds,ecx</span><br><span class="line"></span><br><span class="line">mov edi,[ebx+0x0c] ;获得LDT基地址</span><br><span class="line"></span><br><span class="line">xor ecx,ecx</span><br><span class="line">mov cx,[ebx+0x0a] ;获得LDT界限</span><br><span class="line">inc cx ;LDT的总字节数，即新描述符偏移地址</span><br><span class="line"></span><br><span class="line">mov [edi+ecx+0x00],eax</span><br><span class="line">mov [edi+ecx+0x04],edx ;安装描述符</span><br><span class="line"></span><br><span class="line">add cx,8</span><br><span class="line">dec cx ;得到新的LDT界限值</span><br><span class="line"></span><br><span class="line">mov [ebx+0x0a],cx ;更新LDT界限值到TCB</span><br><span class="line"></span><br><span class="line">mov ax,cx</span><br><span class="line">xor dx,dx</span><br><span class="line">mov cx,8</span><br><span class="line">div cx</span><br><span class="line"></span><br><span class="line">mov cx,ax</span><br><span class="line">shl cx,3 ;左移3位，并且</span><br><span class="line">or cx,0000_0000_0000_0100B ;使TI位=1，指向LDT，最后使RPL=00</span><br><span class="line"></span><br><span class="line">pop ds</span><br><span class="line">pop edi</span><br><span class="line">pop edx</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">load_relocate_program: ;加载并重定位用户程序</span><br><span class="line">;输入: PUSH 逻辑扇区号</span><br><span class="line">; PUSH 任务控制块基地址</span><br><span class="line">;输出：无</span><br><span class="line">pushad</span><br><span class="line"></span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ebp,esp ;为访问通过堆栈传递的参数做准备</span><br><span class="line"></span><br><span class="line">mov ecx,mem_0_4_gb_seg_sel</span><br><span class="line">mov es,ecx</span><br><span class="line"></span><br><span class="line">mov esi,[ebp+11*4] ;从堆栈中取得TCB的基地址</span><br><span class="line"></span><br><span class="line">;以下申请创建LDT所需要的内存</span><br><span class="line">mov ecx,160 ;允许安装20个LDT描述符</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">mov [es:esi+0x0c],ecx ;登记LDT基地址到TCB中</span><br><span class="line">mov word [es:esi+0x0a],0xffff ;登记LDT初始的界限到TCB中</span><br><span class="line"></span><br><span class="line">;以下开始加载用户程序</span><br><span class="line">mov eax,core_data_seg_sel</span><br><span class="line">mov ds,eax ;切换DS到内核数据段</span><br><span class="line"></span><br><span class="line">mov eax,[ebp+12*4] ;从堆栈中取出用户程序起始扇区号</span><br><span class="line">mov ebx,core_buf ;读取程序头部数据</span><br><span class="line">call sys_routine_seg_sel:read_hard_disk_0</span><br><span class="line"></span><br><span class="line">;以下判断整个程序有多大</span><br><span class="line">mov eax,[core_buf] ;程序尺寸</span><br><span class="line">mov ebx,eax</span><br><span class="line">and ebx,0xfffffe00 ;使之512字节对齐（能被512整除的数低</span><br><span class="line">add ebx,512 ;9位都为0</span><br><span class="line">test eax,0x000001ff ;程序的大小正好是512的倍数吗?</span><br><span class="line">cmovnz eax,ebx ;不是。使用凑整的结果</span><br><span class="line"></span><br><span class="line">mov ecx,eax ;实际需要申请的内存数量</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">mov [es:esi+0x06],ecx ;登记程序加载基地址到TCB中</span><br><span class="line"></span><br><span class="line">mov ebx,ecx ;ebx -&gt; 申请到的内存首地址</span><br><span class="line">xor edx,edx</span><br><span class="line">mov ecx,512</span><br><span class="line">div ecx</span><br><span class="line">mov ecx,eax ;总扇区数</span><br><span class="line"></span><br><span class="line">mov eax,mem_0_4_gb_seg_sel ;切换DS到0-4GB的段</span><br><span class="line">mov ds,eax</span><br><span class="line"></span><br><span class="line">mov eax,[ebp+12*4] ;起始扇区号</span><br><span class="line">.b1:</span><br><span class="line">call sys_routine_seg_sel:read_hard_disk_0</span><br><span class="line">inc eax</span><br><span class="line">loop .b1 ;循环读，直到读完整个用户程序</span><br><span class="line"></span><br><span class="line">mov edi,[es:esi+0x06] ;获得程序加载基地址</span><br><span class="line"></span><br><span class="line">;建立程序头部段描述符</span><br><span class="line">mov eax,edi ;程序头部起始线性地址</span><br><span class="line">mov ebx,[edi+0x04] ;段长度</span><br><span class="line">dec ebx ;段界限</span><br><span class="line">mov ecx,0x0040f200 ;字节粒度的数据段描述符，特权级3</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line"></span><br><span class="line">;安装头部段描述符到LDT中</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line"></span><br><span class="line">or cx,0000_0000_0000_0011B ;设置选择子的特权级为3</span><br><span class="line">mov [es:esi+0x44],cx ;登记程序头部段选择子到TCB</span><br><span class="line">mov [edi+0x04],cx ;和头部内</span><br><span class="line"></span><br><span class="line">;建立程序代码段描述符</span><br><span class="line">mov eax,edi</span><br><span class="line">add eax,[edi+0x14] ;代码起始线性地址</span><br><span class="line">mov ebx,[edi+0x18] ;段长度</span><br><span class="line">dec ebx ;段界限</span><br><span class="line">mov ecx,0x0040f800 ;字节粒度的代码段描述符，特权级3</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">or cx,0000_0000_0000_0011B ;设置选择子的特权级为3</span><br><span class="line">mov [edi+0x14],cx ;登记代码段选择子到头部</span><br><span class="line"></span><br><span class="line">;建立程序数据段描述符</span><br><span class="line">mov eax,edi</span><br><span class="line">add eax,[edi+0x1c] ;数据段起始线性地址</span><br><span class="line">mov ebx,[edi+0x20] ;段长度</span><br><span class="line">dec ebx ;段界限</span><br><span class="line">mov ecx,0x0040f200 ;字节粒度的数据段描述符，特权级3</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">or cx,0000_0000_0000_0011B ;设置选择子的特权级为3</span><br><span class="line">mov [edi+0x1c],cx ;登记数据段选择子到头部</span><br><span class="line"></span><br><span class="line">;建立程序堆栈段描述符</span><br><span class="line">mov ecx,[edi+0x0c] ;4KB的倍率</span><br><span class="line">mov ebx,0x000fffff</span><br><span class="line">sub ebx,ecx ;得到段界限</span><br><span class="line">mov eax,4096</span><br><span class="line">mul ecx</span><br><span class="line">mov ecx,eax ;准备为堆栈分配内存</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">add eax,ecx ;得到堆栈的高端物理地址</span><br><span class="line">mov ecx,0x00c0f600 ;字节粒度的堆栈段描述符，特权级3</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">or cx,0000_0000_0000_0011B ;设置选择子的特权级为3</span><br><span class="line">mov [edi+0x08],cx ;登记堆栈段选择子到头部</span><br><span class="line"></span><br><span class="line">;重定位SALT</span><br><span class="line">mov eax,mem_0_4_gb_seg_sel ;这里和前一章不同，头部段描述符</span><br><span class="line">mov es,eax ;已安装，但还没有生效，故只能通</span><br><span class="line">;过4GB段访问用户程序头部</span><br><span class="line">mov eax,core_data_seg_sel</span><br><span class="line">mov ds,eax</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line"></span><br><span class="line">mov ecx,[es:edi+0x24] ;U-SALT条目数(通过访问4GB段取得)</span><br><span class="line">add edi,0x28 ;U-SALT在4GB段内的偏移</span><br><span class="line">.b2:</span><br><span class="line">push ecx</span><br><span class="line">push edi</span><br><span class="line"></span><br><span class="line">mov ecx,salt_items</span><br><span class="line">mov esi,salt</span><br><span class="line">.b3:</span><br><span class="line">push edi</span><br><span class="line">push esi</span><br><span class="line">push ecx</span><br><span class="line"></span><br><span class="line">mov ecx,64 ;检索表中，每条目的比较次数</span><br><span class="line">repe cmpsd ;每次比较4字节</span><br><span class="line">jnz .b4</span><br><span class="line">mov eax,[esi] ;若匹配，则esi恰好指向其后的地址</span><br><span class="line">mov [es:edi-256],eax ;将字符串改写成偏移地址</span><br><span class="line">mov ax,[esi+4]</span><br><span class="line">or ax,0000000000000011B ;以用户程序自己的特权级使用调用门</span><br><span class="line">;故RPL=3</span><br><span class="line">mov [es:edi-252],ax ;回填调用门选择子</span><br><span class="line">.b4:</span><br><span class="line"></span><br><span class="line">pop ecx</span><br><span class="line">pop esi</span><br><span class="line">add esi,salt_item_len</span><br><span class="line">pop edi ;从头比较</span><br><span class="line">loop .b3</span><br><span class="line"></span><br><span class="line">pop edi</span><br><span class="line">add edi,256</span><br><span class="line">pop ecx</span><br><span class="line">loop .b2</span><br><span class="line"></span><br><span class="line">mov esi,[ebp+11*4] ;从堆栈中取得TCB的基地址</span><br><span class="line"></span><br><span class="line">;创建0特权级堆栈</span><br><span class="line">mov ecx,4096</span><br><span class="line">mov eax,ecx ;为生成堆栈高端地址做准备</span><br><span class="line">mov [es:esi+0x1a],ecx</span><br><span class="line">shr dword [es:esi+0x1a],12 ;登记0特权级堆栈尺寸到TCB</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">add eax,ecx ;堆栈必须使用高端地址为基地址</span><br><span class="line">mov [es:esi+0x1e],eax ;登记0特权级堆栈基地址到TCB</span><br><span class="line">mov ebx,0xffffe ;段长度（界限）</span><br><span class="line">mov ecx,0x00c09600 ;4KB粒度，读写，特权级0</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">;or cx,0000_0000_0000_0000 ;设置选择子的特权级为0</span><br><span class="line">mov [es:esi+0x22],cx ;登记0特权级堆栈选择子到TCB</span><br><span class="line">mov dword [es:esi+0x24],0 ;登记0特权级堆栈初始ESP到TCB</span><br><span class="line"></span><br><span class="line">;创建1特权级堆栈</span><br><span class="line">mov ecx,4096</span><br><span class="line">mov eax,ecx ;为生成堆栈高端地址做准备</span><br><span class="line">mov [es:esi+0x28],ecx</span><br><span class="line">shr [es:esi+0x28],12 ;登记1特权级堆栈尺寸到TCB</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">add eax,ecx ;堆栈必须使用高端地址为基地址</span><br><span class="line">mov [es:esi+0x2c],eax ;登记1特权级堆栈基地址到TCB</span><br><span class="line">mov ebx,0xffffe ;段长度（界限）</span><br><span class="line">mov ecx,0x00c0b600 ;4KB粒度，读写，特权级1</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">or cx,0000_0000_0000_0001 ;设置选择子的特权级为1</span><br><span class="line">mov [es:esi+0x30],cx ;登记1特权级堆栈选择子到TCB</span><br><span class="line">mov dword [es:esi+0x32],0 ;登记1特权级堆栈初始ESP到TCB</span><br><span class="line"></span><br><span class="line">;创建2特权级堆栈</span><br><span class="line">mov ecx,4096</span><br><span class="line">mov eax,ecx ;为生成堆栈高端地址做准备</span><br><span class="line">mov [es:esi+0x36],ecx</span><br><span class="line">shr [es:esi+0x36],12 ;登记2特权级堆栈尺寸到TCB</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">add eax,ecx ;堆栈必须使用高端地址为基地址</span><br><span class="line">mov [es:esi+0x3a],ecx ;登记2特权级堆栈基地址到TCB</span><br><span class="line">mov ebx,0xffffe ;段长度（界限）</span><br><span class="line">mov ecx,0x00c0d600 ;4KB粒度，读写，特权级2</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">mov ebx,esi ;TCB的基地址</span><br><span class="line">call fill_descriptor_in_ldt</span><br><span class="line">or cx,0000_0000_0000_0010 ;设置选择子的特权级为2</span><br><span class="line">mov [es:esi+0x3e],cx ;登记2特权级堆栈选择子到TCB</span><br><span class="line">mov dword [es:esi+0x40],0 ;登记2特权级堆栈初始ESP到TCB</span><br><span class="line"></span><br><span class="line">;在GDT中登记LDT描述符</span><br><span class="line">mov eax,[es:esi+0x0c] ;LDT的起始线性地址</span><br><span class="line">movzx ebx,word [es:esi+0x0a] ;LDT段界限</span><br><span class="line">mov ecx,0x00408200 ;LDT描述符，特权级0</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">mov [es:esi+0x10],cx ;登记LDT选择子到TCB中</span><br><span class="line"></span><br><span class="line">;创建用户程序的TSS</span><br><span class="line">mov ecx,104 ;tss的基本尺寸</span><br><span class="line">mov [es:esi+0x12],cx</span><br><span class="line">dec word [es:esi+0x12] ;登记TSS界限值到TCB</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">mov [es:esi+0x14],ecx ;登记TSS基地址到TCB</span><br><span class="line"></span><br><span class="line">;登记基本的TSS表格内容</span><br><span class="line">mov word [es:ecx+0],0 ;反向链=0</span><br><span class="line"></span><br><span class="line">mov edx,[es:esi+0x24] ;登记0特权级堆栈初始ESP</span><br><span class="line">mov [es:ecx+4],edx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov dx,[es:esi+0x22] ;登记0特权级堆栈段选择子</span><br><span class="line">mov [es:ecx+8],dx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov edx,[es:esi+0x32] ;登记1特权级堆栈初始ESP</span><br><span class="line">mov [es:ecx+12],edx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov dx,[es:esi+0x30] ;登记1特权级堆栈段选择子</span><br><span class="line">mov [es:ecx+16],dx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov edx,[es:esi+0x40] ;登记2特权级堆栈初始ESP</span><br><span class="line">mov [es:ecx+20],edx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov dx,[es:esi+0x3e] ;登记2特权级堆栈段选择子</span><br><span class="line">mov [es:ecx+24],dx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov dx,[es:esi+0x10] ;登记任务的LDT选择子</span><br><span class="line">mov [es:ecx+96],dx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov dx,[es:esi+0x12] ;登记任务的I/O位图偏移</span><br><span class="line">mov [es:ecx+102],dx ;到TSS中</span><br><span class="line"></span><br><span class="line">mov word [es:ecx+100],0 ;T=0</span><br><span class="line"></span><br><span class="line">;在GDT中登记TSS描述符</span><br><span class="line">mov eax,[es:esi+0x14] ;TSS的起始线性地址</span><br><span class="line">movzx ebx,word [es:esi+0x12] ;段长度（界限）</span><br><span class="line">mov ecx,0x00408900 ;TSS描述符，特权级0</span><br><span class="line">call sys_routine_seg_sel:make_seg_descriptor</span><br><span class="line">call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">mov [es:esi+0x18],cx ;登记TSS选择子到TCB</span><br><span class="line"></span><br><span class="line">pop es ;恢复到调用此过程前的es段</span><br><span class="line">pop ds ;恢复到调用此过程前的ds段</span><br><span class="line"></span><br><span class="line">popad</span><br><span class="line"></span><br><span class="line">ret 8 ;丢弃调用本过程前压入的参数</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">append_to_tcb_link: ;在TCB链上追加任务控制块</span><br><span class="line">;输入：ECX=TCB线性基地址</span><br><span class="line">push eax</span><br><span class="line">push edx</span><br><span class="line">push ds</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov eax,core_data_seg_sel ;令DS指向内核数据段</span><br><span class="line">mov ds,eax</span><br><span class="line">mov eax,mem_0_4_gb_seg_sel ;令ES指向0..4GB段</span><br><span class="line">mov es,eax</span><br><span class="line"></span><br><span class="line">mov dword [es: ecx+0x00],0 ;当前TCB指针域清零，以指示这是最</span><br><span class="line">;后一个TCB</span><br><span class="line"></span><br><span class="line">mov eax,[tcb_chain] ;TCB表头指针</span><br><span class="line">or eax,eax ;链表为空？</span><br><span class="line">jz .notcb</span><br><span class="line"></span><br><span class="line">.searc:</span><br><span class="line">mov edx,eax</span><br><span class="line">mov eax,[es: edx+0x00]</span><br><span class="line">or eax,eax</span><br><span class="line">jnz .searc</span><br><span class="line"></span><br><span class="line">mov [es: edx+0x00],ecx</span><br><span class="line">jmp .retpc</span><br><span class="line"></span><br><span class="line">.notcb:</span><br><span class="line">mov [tcb_chain],ecx ;若为空表，直接令表头指针指向TCB</span><br><span class="line"></span><br><span class="line">.retpc:</span><br><span class="line">pop es</span><br><span class="line">pop ds</span><br><span class="line">pop edx</span><br><span class="line">pop eax</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">start:</span><br><span class="line">mov ecx,core_data_seg_sel ;使ds指向核心数据段</span><br><span class="line">mov ds,ecx</span><br><span class="line"></span><br><span class="line">mov ebx,message_1</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">;显示处理器品牌信息</span><br><span class="line">mov eax,0x80000002</span><br><span class="line">cpuid</span><br><span class="line">mov [cpu_brand + 0x00],eax</span><br><span class="line">mov [cpu_brand + 0x04],ebx</span><br><span class="line">mov [cpu_brand + 0x08],ecx</span><br><span class="line">mov [cpu_brand + 0x0c],edx</span><br><span class="line"></span><br><span class="line">mov eax,0x80000003</span><br><span class="line">cpuid</span><br><span class="line">mov [cpu_brand + 0x10],eax</span><br><span class="line">mov [cpu_brand + 0x14],ebx</span><br><span class="line">mov [cpu_brand + 0x18],ecx</span><br><span class="line">mov [cpu_brand + 0x1c],edx</span><br><span class="line"></span><br><span class="line">mov eax,0x80000004</span><br><span class="line">cpuid</span><br><span class="line">mov [cpu_brand + 0x20],eax</span><br><span class="line">mov [cpu_brand + 0x24],ebx</span><br><span class="line">mov [cpu_brand + 0x28],ecx</span><br><span class="line">mov [cpu_brand + 0x2c],edx</span><br><span class="line"></span><br><span class="line">mov ebx,cpu_brnd0 ;显示处理器品牌信息</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line">mov ebx,cpu_brand</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line">mov ebx,cpu_brnd1</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门</span><br><span class="line">mov edi,salt ;C-SALT表的起始位置</span><br><span class="line">mov ecx,salt_items ;C-SALT表的条目数量</span><br><span class="line">.b3:</span><br><span class="line">push ecx</span><br><span class="line">mov eax,[edi+256] ;该条目入口点的32位偏移地址</span><br><span class="line">mov bx,[edi+260] ;该条目入口点的段选择子</span><br><span class="line">mov cx,1_11_0_1100_000_00000B ;特权级3的调用门(3以上的特权级才</span><br><span class="line">;允许访问)，0个参数(因为用寄存器</span><br><span class="line">;传递参数，而没有用栈)</span><br><span class="line">call sys_routine_seg_sel:make_gate_descriptor</span><br><span class="line">call sys_routine_seg_sel:set_up_gdt_descriptor</span><br><span class="line">mov [edi+260],cx ;将返回的门描述符选择子回填</span><br><span class="line">add edi,salt_item_len ;指向下一个C-SALT条目</span><br><span class="line">pop ecx</span><br><span class="line">loop .b3</span><br><span class="line"></span><br><span class="line">;对门进行测试</span><br><span class="line">mov ebx,message_2</span><br><span class="line">call far [salt_1+256] ;通过门显示信息(偏移量将被忽略)</span><br><span class="line"></span><br><span class="line">mov ebx,message_3</span><br><span class="line">call sys_routine_seg_sel:put_string ;在内核中调用例程不需要通过门</span><br><span class="line"></span><br><span class="line">;创建任务控制块。这不是处理器的要求，而是我们自己为了方便而设立的</span><br><span class="line">mov ecx,0x46</span><br><span class="line">call sys_routine_seg_sel:allocate_memory</span><br><span class="line">call append_to_tcb_link ;将任务控制块追加到TCB链表</span><br><span class="line"></span><br><span class="line">push dword 50 ;用户程序位于逻辑50扇区</span><br><span class="line">push ecx ;压入任务控制块起始线性地址</span><br><span class="line"></span><br><span class="line">call load_relocate_program</span><br><span class="line"></span><br><span class="line">mov ebx,do_status</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">mov eax,mem_0_4_gb_seg_sel</span><br><span class="line">mov ds,eax</span><br><span class="line"></span><br><span class="line">ltr [ecx+0x18] ;加载任务状态段</span><br><span class="line">lldt [ecx+0x10] ;加载LDT</span><br><span class="line"></span><br><span class="line">mov eax,[ecx+0x44]</span><br><span class="line">mov ds,eax ;切换到用户程序头部段</span><br><span class="line"></span><br><span class="line">;以下假装是从调用门返回。摹仿处理器压入返回参数</span><br><span class="line">push dword [0x08] ;调用前的堆栈段选择子</span><br><span class="line">push dword 0 ;调用前的esp</span><br><span class="line"></span><br><span class="line">push dword [0x14] ;调用前的代码段选择子</span><br><span class="line">push dword [0x10] ;调用前的eip</span><br><span class="line"></span><br><span class="line">retf</span><br><span class="line"></span><br><span class="line">return_point: ;用户程序返回点</span><br><span class="line">mov eax,core_data_seg_sel ;因为c14.asm是以JMP的方式使用调</span><br><span class="line">mov ds,eax ;用门@TerminateProgram，回到这</span><br><span class="line">;里时，特权级为3，会导致异常。</span><br><span class="line">mov ebx,message_6</span><br><span class="line">call sys_routine_seg_sel:put_string</span><br><span class="line"></span><br><span class="line">hlt</span><br><span class="line"></span><br><span class="line">core_code_end:</span><br><span class="line"></span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">SECTION core_trail</span><br><span class="line">;-------------------------------------------------------------------------------</span><br><span class="line">core_end:</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ysjcqs.top">幽姝</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ysjcqs.top/posts/9089e2fd.html">https://ysjcqs.top/posts/9089e2fd.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ysjcqs.top" target="_blank">谨尘青丝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 🎁打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg" alt="微信支付"/></a><div class="post-qr-code-desc">微信支付</div></li><li class="reward-item"><a href="/img/ali_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/ali_pay.jpg" alt="支付宝支付"/></a><div class="post-qr-code-desc">支付宝支付</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/7845ca80.html"><img class="next-cover" src="https://img.paulzzh.com/touhou/random" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Arch Linux 从安装到美化记录</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Utterances</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar_img.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">幽姝</div><div class="author-info__description">让彼岸，叶与花相拥!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/40581568"><i class="icon-bilibili"></i><span>bilibili</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/YSjcqs" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ysjcqs@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=344103612&amp;website=www.oicqzone.com" target="_blank" title=""><i class="fa-brands fa-qq"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F-8086%E9%98%B6%E6%AE%B5"><span class="toc-number">1.</span> <span class="toc-text">实模式+8086阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%A8%A1%E5%BC%8F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.1.</span> <span class="toc-text">实模式内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">指针寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.4.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.2.5.</span> <span class="toc-text">可以提供偏移地址的寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E9%A2%9C%E8%89%B2%E8%A1%A8%EF%BC%8880-X-25%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">文本模式颜色表（80 X 25）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%AF%B9flags%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.5.</span> <span class="toc-text">指令对flags寄存器的影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.1.</span> <span class="toc-text">寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.2.</span> <span class="toc-text">立即数寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.3.</span> <span class="toc-text">内存寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.4.</span> <span class="toc-text">基址寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">1.6.5.</span> <span class="toc-text">基址变址寻址:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">用户程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%A4%E4%BA%92"><span class="toc-number">1.8.</span> <span class="toc-text">设备交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%EF%BC%88%E5%9D%97%E8%AE%BE%E5%A4%87%EF%BC%89"><span class="toc-number">1.8.1.</span> <span class="toc-text">硬盘（块设备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%8D%A1"><span class="toc-number">1.8.2.</span> <span class="toc-text">显卡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8259%E8%8A%AF%E7%89%87"><span class="toc-number">1.8.3.</span> <span class="toc-text">8259芯片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F%EF%BC%88Real-Time-Clock-RTC%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">实时时钟（Real Time Clock:RTC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">中断信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%EF%BC%88Interrupt-Vector-Table%EF%BC%9AIVT%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">中断向量表（Interrupt Vector Table：IVT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E5%8F%91%E7%94%9F%E4%B8%AD%E6%96%AD%E7%9A%84%E6%97%B6%E6%9C%9F"><span class="toc-number">1.9.2.</span> <span class="toc-text">无法发生中断的时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%88%AB"><span class="toc-number">1.9.3.</span> <span class="toc-text">中断类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">硬件中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">内部中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">软中断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.4.</span> <span class="toc-text">中断处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIOS%E4%B8%AD%E6%96%AD%E8%B0%83%E7%94%A8"><span class="toc-number">1.9.5.</span> <span class="toc-text">BIOS中断调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.10.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3%E2%80%A6-100"><span class="toc-number">1.10.1.</span> <span class="toc-text">1+2+3…+100</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.2.</span> <span class="toc-text">基址变址寻址的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">1.10.3.</span> <span class="toc-text">用户程序头部信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E4%BB%A3%E7%A0%81%EF%BC%88%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">1.10.4.</span> <span class="toc-text">硬盘主引导扇区代码（加载程序）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTC%E5%91%A8%E6%9C%9F%E4%B8%AD%E6%96%AD-%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4"><span class="toc-number">1.10.5.</span> <span class="toc-text">RTC周期中断,显示时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BIOS%E5%8A%9F%E8%83%BD%E8%B0%83%E7%94%A8"><span class="toc-number">1.10.6.</span> <span class="toc-text">BIOS功能调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F-x86%E9%98%B6%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">保护模式+x86阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-2"><span class="toc-number">2.1.</span> <span class="toc-text">寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8-2"><span class="toc-number">2.1.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%99%A8-%E8%BF%98%E6%98%AF16%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E4%BD%86%E4%BD%9C%E7%94%A8%E5%8F%91%E7%94%9F%E4%BA%86%E6%94%B9%E5%8F%98"><span class="toc-number">2.1.2.</span> <span class="toc-text">段选择器(还是16位寄存器，但作用发生了改变)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90-16%E4%BD%8D"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">段选择子(16位)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E5%AF%84%E5%AD%98%E5%99%A8GDTR"><span class="toc-number">2.1.3.</span> <span class="toc-text">全局描述符表寄存器GDTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.1.4.</span> <span class="toc-text">控制寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8-2"><span class="toc-number">2.1.5.</span> <span class="toc-text">标志寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E5%AF%84%E5%AD%98%E5%99%A8TR"><span class="toc-number">2.1.6.</span> <span class="toc-text">任务寄存器TR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E5%AF%84%E5%AD%98%E5%99%A8LDTR"><span class="toc-number">2.1.7.</span> <span class="toc-text">局部描述符表寄存器LDTR</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BD%8D%E5%86%85%E5%AD%98%E5%8C%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">高位内存区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-2"><span class="toc-number">2.3.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">内存寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4-2"><span class="toc-number">2.4.</span> <span class="toc-text">指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.4.2.</span> <span class="toc-text">串比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8"><span class="toc-number">2.4.3.</span> <span class="toc-text">操作尺寸</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%93%8D%E4%BD%9C%E5%B0%BA%E5%AF%B8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">默认操作尺寸</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E5%8E%8B%E5%85%A5%E7%AB%8B%E5%8D%B3%E6%95%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">push压入立即数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#push%E5%8E%8B%E5%85%A5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">2.4.5.</span> <span class="toc-text">push压入寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">指令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%A4%E4%BA%92-2"><span class="toc-number">2.6.</span> <span class="toc-text">设备交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A30x92"><span class="toc-number">2.6.1.</span> <span class="toc-text">端口0x92</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPUID"><span class="toc-number">2.6.2.</span> <span class="toc-text">CPUID</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.7.</span> <span class="toc-text">段描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">段描述符和描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8"><span class="toc-number">2.7.2.</span> <span class="toc-text">全局描述符表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.3.</span> <span class="toc-text">描述符属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.7.3.1.</span> <span class="toc-text">描述符的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">2.7.3.2.</span> <span class="toc-text">存储器的描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%AE%B5%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.7.4.</span> <span class="toc-text">代码段执行的保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E6%89%A9%E5%B1%95%E7%9A%84%E6%A0%88%E6%AE%B5%E7%9A%84%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.7.5.</span> <span class="toc-text">向上扩展的栈段的保护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GDT"><span class="toc-number">2.8.</span> <span class="toc-text">GDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LDT"><span class="toc-number">2.9.</span> <span class="toc-text">LDT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSS"><span class="toc-number">2.10.</span> <span class="toc-text">TSS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.11.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GDT%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.11.1.</span> <span class="toc-text">GDT使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">2.11.2.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C"><span class="toc-number">2.11.3.</span> <span class="toc-text">保护模式程序的动态加载和执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.11.3.1.</span> <span class="toc-text">主引导程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.11.3.2.</span> <span class="toc-text">内核程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">2.11.3.3.</span> <span class="toc-text">用户程序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ldt-tss%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.11.4.</span> <span class="toc-text">ldt tss的使用</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/356b66.html" title="3D数学基础：图形和游戏开发 读书笔记 第8章"><img src="https://api.mtyqx.cn/tapi/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D数学基础：图形和游戏开发 读书笔记 第8章"/></a><div class="content"><a class="title" href="/posts/356b66.html" title="3D数学基础：图形和游戏开发 读书笔记 第8章">3D数学基础：图形和游戏开发 读书笔记 第8章</a><time datetime="2023-03-18T10:34:41.000Z" title="发表于 2023-03-18 18:34:41">2023-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5a8a6c8d.html" title="3D数学基础：图形和游戏开发 读书笔记 第7章"><img src="https://api.ixiaowai.cn/api/api.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D数学基础：图形和游戏开发 读书笔记 第7章"/></a><div class="content"><a class="title" href="/posts/5a8a6c8d.html" title="3D数学基础：图形和游戏开发 读书笔记 第7章">3D数学基础：图形和游戏开发 读书笔记 第7章</a><time datetime="2023-03-16T00:48:54.000Z" title="发表于 2023-03-16 08:48:54">2023-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/e0ea1c55.html" title="3D数学基础：图形和游戏开发 读书笔记 第6章"><img src="https://api.ucany.net/acg-pc.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D数学基础：图形和游戏开发 读书笔记 第6章"/></a><div class="content"><a class="title" href="/posts/e0ea1c55.html" title="3D数学基础：图形和游戏开发 读书笔记 第6章">3D数学基础：图形和游戏开发 读书笔记 第6章</a><time datetime="2023-03-15T00:48:48.000Z" title="发表于 2023-03-15 08:48:48">2023-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f25fb3bb.html" title="3D数学基础：图形和游戏开发 读书笔记 第5章"><img src="https://api.r10086.com/img-api.php?type=动漫综合7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D数学基础：图形和游戏开发 读书笔记 第5章"/></a><div class="content"><a class="title" href="/posts/f25fb3bb.html" title="3D数学基础：图形和游戏开发 读书笔记 第5章">3D数学基础：图形和游戏开发 读书笔记 第5章</a><time datetime="2023-03-14T00:51:24.000Z" title="发表于 2023-03-14 08:51:24">2023-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4ae3d4de.html" title="3D数学基础：图形和游戏开发 读书笔记 第4章"><img src="https://api.mtyqx.cn/api/random.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3D数学基础：图形和游戏开发 读书笔记 第4章"/></a><div class="content"><a class="title" href="/posts/4ae3d4de.html" title="3D数学基础：图形和游戏开发 读书笔记 第4章">3D数学基础：图形和游戏开发 读书笔记 第4章</a><time datetime="2023-03-13T05:02:49.000Z" title="发表于 2023-03-13 13:02:49">2023-03-13</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'YSjcqs/YSjcqs.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme () {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

if ('Utterances' === 'Utterances' || !false) {
  if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'oQjeydZXPQQ6Mrsb5PLq9YWe-gzGzoHsz',
      appKey: 'dJQQQkdLku3mMqDlnYkUvvP1',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Utterances' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>